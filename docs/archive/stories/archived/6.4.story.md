# Story 6.4: Historical Performance Tracking (Future)

## Status

Done

## Story

**As a** content creator,
**I want** the system to learn from my posted content's performance,
**so that** time recommendations improve over time based on my audience. _(Note: This story is a placeholder for future enhancement when API access to engagement metrics becomes available.)_

## Acceptance Criteria

1. A `post_performance` table is defined in the Convex schema with fields: `postId`, `platform`, `publishedTime`, `engagementMetrics` (likes, shares, comments), `fetchedAt`.
2. A Convex action periodically fetches engagement metrics from Twitter/LinkedIn APIs (if access is available).
3. Fetched performance data is stored in the `post_performance` table linked to the original post.
4. The time suggestion algorithm considers historical performance when calculating recommendations (weighted average with research-based data).
5. Users can view a "Performance Insights" page showing their best-performing posting times.
6. This feature remains inactive until API access to engagement metrics is configured.
7. Documentation notes the API requirements and setup steps for enabling this feature.

## Tasks / Subtasks

- [x] Task 1: Define `post_performance` schema in `convex/schema.ts` (AC: 1)
  - [x] Add `post_performance` table with fields: `postId`, `platform`, `publishedTime`, `engagementMetrics`, `fetchedAt`
  - [x] Use Convex validators for type safety (`v.id("posts")` for postId, `v.object()` for engagementMetrics)
  - [x] Define `engagementMetrics` structure: `{ likes: number, shares: number, comments: number, impressions?: number }`
  - [x] Add index `by_post` on `["postId"]` for efficient post-specific lookups
  - [x] Add index `by_platform_time` on `["platform", "publishedTime"]` for time-based analysis
  - [x] Document schema fields with inline comments explaining future activation

- [x] Task 2: Create stub Convex action for fetching engagement metrics (AC: 2)
  - [x] Create `convex/analytics.ts` file for performance tracking logic
  - [x] Add `"use node";` directive for Node.js runtime (required for external API calls)
  - [x] Define action `fetchEngagementMetrics` with parameters: `postId`, `platform`
  - [x] Implement stub logic that returns mock data or throws "not implemented" error
  - [x] Add authentication check to ensure only the post owner can fetch metrics
  - [x] Document required API endpoints for Twitter and LinkedIn engagement data
  - [x] Add placeholder for API key environment variables (TWITTER_API_KEY, LINKEDIN_API_KEY)

- [x] Task 3: Create mutation to store performance data (AC: 3)
  - [x] Define mutation `storePerformanceData` in `convex/analytics.ts`
  - [x] Accept parameters: `postId`, `platform`, `engagementMetrics`
  - [x] Validate that postId exists and belongs to the authenticated user
  - [x] Insert record into `post_performance` table with current timestamp as `fetchedAt`
  - [x] Link to original post via `postId` (foreign key relationship)
  - [x] Add error handling for duplicate entries (update existing if re-fetching metrics)

- [x] Task 4: Create placeholder for scheduled metric fetching (AC: 2)
  - [x] Define scheduled function stub `scheduledMetricsFetch` in `convex/analytics.ts`
  - [x] Document intended schedule: daily or every 6 hours
  - [x] Add logic to query all published posts from past 7 days
  - [x] Loop through posts and call `fetchEngagementMetrics` action for each
  - [x] Add rate limiting logic to respect API quotas (Twitter/LinkedIn rate limits)
  - [x] Mark function as inactive (commented out or feature-flagged) until API access is configured

- [x] Task 5: Enhance recommendation algorithm with historical performance weighting (AC: 4)
  - [x] Modify `getRecommendedTimes` query in `convex/recommendations.ts`
  - [x] Add optional logic to query `post_performance` table for user's historical data
  - [x] Calculate average engagement by hour of day for each platform
  - [x] Weight research-based engagement scores with historical performance factor
  - [x] Example formula: `finalScore = (researchScore * 0.6) + (historicalScore * 0.4)`
  - [x] Add feature flag to enable/disable historical weighting (default: disabled)
  - [x] Document how weighting algorithm works in code comments

- [x] Task 6: Create "Performance Insights" UI page (AC: 5)
  - [x] Create new page `app/insights/page.tsx` for performance insights
  - [x] Add route protection via Clerk middleware (authenticated users only)
  - [x] Create Convex query to aggregate performance data by time of day
  - [x] Display chart/graph showing best-performing posting times (use chart library like Recharts)
  - [x] Show engagement metrics breakdown (likes, shares, comments)
  - [x] Add filter by platform (Twitter vs LinkedIn)
  - [x] Add filter by date range (last 7 days, 30 days, all time)
  - [x] Show "Feature not yet active" message if no performance data exists

- [x] Task 7: Document API requirements and setup steps (AC: 6, 7)
  - [x] Create documentation file: `docs/features/performance-tracking.md`
  - [x] Document Twitter/X API requirements for engagement metrics
  - [x] Document LinkedIn API requirements for engagement metrics
  - [x] List required OAuth scopes for accessing analytics data
  - [x] Provide step-by-step setup guide for obtaining API credentials
  - [x] Document rate limits and quota considerations for each platform
  - [x] Include troubleshooting section for common API access issues
  - [x] Add note about API pricing and potential costs

- [x] Task 8: Add feature flag system for gradual activation (AC: 6)
  - [x] Create feature flag configuration (e.g., in environment variables or Convex config)
  - [x] Add `PERFORMANCE_TRACKING_ENABLED` flag (default: false)
  - [x] Gate all performance tracking logic behind this flag
  - [x] Show/hide "Performance Insights" nav link based on flag
  - [x] Display setup instructions when flag is false but user tries to access feature
  - [x] Add admin toggle to enable feature when API access is configured

- [x] Task 9: Write unit tests for performance tracking logic (AC: 1-4)
  - [x] Test `post_performance` schema validation
  - [x] Test `storePerformanceData` mutation with valid and invalid data
  - [x] Test engagement metrics calculation logic
  - [x] Test historical weighting algorithm with mock data
  - [x] Test feature flag behavior (enabled vs disabled states)

- [x] Task 10: Write integration tests (AC: 2, 3)
  - [x] Test full flow: fetch metrics → store data → aggregate insights
  - [x] Test scheduled function logic (with mocked API responses)
  - [x] Test authentication requirements for all actions/mutations
  - [x] Test recommendation algorithm with historical performance data
  - [x] Test "Performance Insights" page rendering with real data

## Dev Notes

### Previous Story Insights

[Source: Story 6.1, Story 6.2, Story 6.3]

- The `posting_time_recommendations` table exists with research-based best practices
- The `getRecommendedTimes` query returns top 3 suggestions sorted by engagement score
- The UI displays recommendations in the post scheduler with auto-fill functionality
- All recommendations are currently based on industry research only
- This story adds personalization based on the user's own posting history

### Data Models

**Existing Tables:** [Source: docs/architecture/data-models.md]

1. **`posts`**
   - Fields: `clerkUserId`, `status`, `twitterContent`, `linkedInContent`, `twitterScheduledTime`, `linkedInScheduledTime`, etc.
   - Index: `by_user` on `["clerkUserId"]`
   - Used to track which posts have been published and need metrics fetched

2. **`posting_time_recommendations`** [Source: Story 6.1]
   - Fields: `platform`, `dayOfWeek`, `hourRanges`, `engagementScore`, `source`
   - Index: `by_platform_day` on `["platform", "dayOfWeek"]`
   - Used for research-based recommendations

**New Table: `post_performance`**

This story introduces a new table for tracking historical engagement metrics:

**Required Fields:**

- `postId`: `v.id("posts")` - Link to original post
- `platform`: string - "twitter" or "linkedin"
- `publishedTime`: number - Timestamp when post was published (copy from `posts.twitterScheduledTime` or `linkedInScheduledTime`)
- `engagementMetrics`: object - `{ likes: number, shares: number, comments: number, impressions?: number }`
- `fetchedAt`: number - Timestamp when metrics were fetched from API

**Index Requirements:**

- `by_post` on `["postId"]` - Lookup metrics for a specific post
- `by_platform_time` on `["platform", "publishedTime"]` - Aggregate metrics by time of day

**Example Data Structure:**

```typescript
{
  postId: "j97x8y3z9...", // Convex ID
  platform: "twitter",
  publishedTime: 1699545600000, // Nov 9, 2023, 9:00 AM UTC
  engagementMetrics: {
    likes: 42,
    shares: 8,
    comments: 5,
    impressions: 1200
  },
  fetchedAt: 1699632000000 // 24 hours after publishing
}
```

### Schema Implementation Guidance

[Source: CLAUDE.md, docs/architecture/data-models.md]

**Convex Schema Location:** `convex/schema.ts`

**Validator Patterns:**

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // ... existing tables ...
  post_performance: defineTable({
    postId: v.id("posts"),
    platform: v.string(),
    publishedTime: v.number(),
    engagementMetrics: v.object({
      likes: v.number(),
      shares: v.number(),
      comments: v.number(),
      impressions: v.optional(v.number()),
    }),
    fetchedAt: v.number(),
  })
    .index("by_post", ["postId"])
    .index("by_platform_time", ["platform", "publishedTime"]),
});
```

### Action Implementation for External APIs

[Source: CLAUDE.md - Critical Architectural Patterns]

**Actions with Node.js Runtime:**

```typescript
"use node";

import { action } from "./_generated/server";
import { v } from "convex/values";

export const fetchEngagementMetrics = action({
  args: {
    postId: v.id("posts"),
    platform: v.string(),
  },
  returns: v.object({
    likes: v.number(),
    shares: v.number(),
    comments: v.number(),
    impressions: v.optional(v.number()),
  }),
  handler: async (ctx, args) => {
    // Authentication check
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    // TODO: Implement actual API calls when access is available
    throw new Error(
      "Performance tracking not yet implemented - API access required",
    );

    // Future implementation:
    // 1. Retrieve post data to get platform-specific post ID
    // 2. Call Twitter/LinkedIn API to fetch engagement metrics
    // 3. Parse and return metrics
  },
});
```

**Environment Variables for API Keys:**

- Store API keys in Convex Environment Variables (never in code)
- Access via `process.env.TWITTER_API_KEY` in actions
- Document required environment variables in setup guide

### Twitter/X API for Engagement Metrics

**Required API Endpoint:**

- Twitter API v2: `GET /2/tweets/:id` with `tweet.fields=public_metrics`
- Returns: `{ public_metrics: { like_count, retweet_count, reply_count, impression_count } }`

**OAuth Scopes Needed:**

- `tweet.read` - Read tweet data
- Analytics access may require Twitter API Premium or Enterprise tier

**Rate Limits:**

- Twitter API v2 Free tier: 500,000 tweets/month (read)
- Rate limit: 900 requests per 15-minute window (per user)

**Documentation:**

- <https://developer.twitter.com/en/docs/twitter-api/metrics>

### LinkedIn API for Engagement Metrics

**Required API Endpoint:**

- LinkedIn API: `GET /v2/socialActions/{shareUrn}/statistics`
- Returns: `{ totalShareStatistics: { shareCount, likeCount, commentCount, impressionCount } }`

**OAuth Scopes Needed:**

- `r_organization_social` - Read organization social data (for personal posts, may differ)
- Analytics access may require LinkedIn Marketing Developer Platform

**Rate Limits:**

- LinkedIn API: Varies by tier, typically 100 requests per day for basic access

**Documentation:**

- <https://docs.microsoft.com/en-us/linkedin/marketing/integrations/community-management/shares/share-statistics>

### Historical Performance Weighting Algorithm

**Objective:** Combine research-based recommendations with user's historical performance data

**Algorithm Design:**

```typescript
// Pseudo-code for weighting logic
function calculateFinalScore(researchScore, historicalData, hourOfDay) {
  // Calculate historical score for this hour
  const postsAtThisHour = historicalData.filter(
    (p) => getHourOfDay(p.publishedTime) === hourOfDay,
  );
  const avgEngagement =
    postsAtThisHour.reduce((sum, p) => sum + p.engagementMetrics.likes, 0) /
    postsAtThisHour.length;

  // Normalize historical score to 0-100 scale
  const historicalScore = normalizeEngagement(avgEngagement);

  // Weight research vs historical (60/40 split)
  const finalScore = researchScore * 0.6 + historicalScore * 0.4;

  return finalScore;
}
```

**Implementation Notes:**

- If user has < 10 posts at a specific hour, rely more heavily on research data
- Decay older posts (give more weight to recent 30 days)
- Handle platforms separately (Twitter vs LinkedIn have different engagement scales)

### Scheduled Functions for Periodic Fetching

[Source: CLAUDE.md - Scheduled Publishing Architecture]

**Convex Scheduled Functions:**

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

crons.daily(
  "fetch-engagement-metrics",
  { hourUTC: 6 }, // Run at 6 AM UTC daily
  internal.analytics.scheduledMetricsFetch,
);

export default crons;
```

**Scheduled Function Implementation:**

```typescript
export const scheduledMetricsFetch = internalAction({
  args: {},
  handler: async (ctx) => {
    // Query all published posts from past 7 days
    // For each post, call fetchEngagementMetrics
    // Store results via storePerformanceData mutation
  },
});
```

### Feature Flag System

**Environment Variable Approach:**

```typescript
// In Convex environment variables:
PERFORMANCE_TRACKING_ENABLED = false;

// In code:
const isPerformanceTrackingEnabled =
  process.env.PERFORMANCE_TRACKING_ENABLED === "true";

if (!isPerformanceTrackingEnabled) {
  throw new Error(
    "Performance tracking is not yet enabled. Configure API access first.",
  );
}
```

**Frontend Conditional Rendering:**

```typescript
// In navigation or insights page
{isFeatureEnabled("performance-tracking") && (
  <Link href="/insights">Performance Insights</Link>
)}
```

### File Locations

**New Files:**

- `convex/analytics.ts` - Performance tracking actions and mutations
- `app/insights/page.tsx` - Performance Insights UI page
- `components/features/PerformanceChart.tsx` - Chart component for insights (optional)
- `docs/features/performance-tracking.md` - Setup and API documentation

**Modified Files:**

- `convex/schema.ts` - Add `post_performance` table
- `convex/recommendations.ts` - Enhance with historical weighting logic
- `convex/cron.ts` (or similar) - Add scheduled metric fetching cron job

**Existing Files:**

- `convex/_generated/api.ts` - Auto-generated API references

### Testing

[Source: docs/architecture/testing-strategy.md]

**Unit Testing Focus:**

- Schema validation for `post_performance` table
- Engagement metrics calculation logic
- Historical weighting algorithm
- Feature flag behavior

**Integration Testing Focus:**

- Full flow: fetch metrics → store → aggregate → display
- Authentication checks in actions/mutations
- Scheduled function execution (with mocked API calls)
- Recommendation algorithm with real performance data

**Action Testing Focus:** [Source: docs/architecture/testing-strategy.md]

- Mock external APIs (Twitter/LinkedIn) for testing
- Test rate limit handling
- Test retry logic for API failures
- Test data parsing from API responses

**Test Tools:**

- Jest for unit tests
- Mocking libraries for Twitter/LinkedIn API responses
- Convex testing utilities for database operations

### Technical Constraints

**Authentication:** [Source: docs/architecture/security.md]

- All actions/mutations must verify user authentication
- Users can only fetch/view metrics for their own posts
- Admin actions (scheduled fetch) should use internal mutations

**API Rate Limiting:**

- Respect Twitter and LinkedIn API rate limits
- Implement exponential backoff for rate-limited requests
- Log rate limit errors for monitoring
- Consider batching requests to minimize API calls

**Error Handling:**

- If API access is unavailable, gracefully fallback to research-based recommendations
- Log API errors but don't block post scheduling functionality
- Notify user if metrics fetching fails (optional)

**Performance:**

- Cache aggregated insights to avoid repeated calculations
- Use indexes efficiently for time-based queries
- Limit historical data to past 90 days to keep queries fast

### Security Considerations

[Source: docs/architecture/security.md]

**API Key Management:**

- Store API keys in Convex Environment Variables
- Never expose keys in client-side code or logs
- Rotate keys periodically for security

**Data Privacy:**

- Engagement metrics are user-specific (scoped to `clerkUserId`)
- Do not expose one user's performance data to another user
- Validate postId belongs to authenticated user before storing metrics

### Future Enhancement Notes

**Potential Improvements:**

- ML-based time recommendation using historical data
- A/B testing framework to validate recommendation effectiveness
- Engagement predictions based on content type (text, images, links)
- Competitor benchmarking (compare user's performance to industry averages)

## Change Log

| Date       | Version | Description                 | Author             |
| ---------- | ------- | --------------------------- | ------------------ |
| 2025-11-03 | 1.0     | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (model ID: claude-sonnet-4-5-20250929)

### Debug Log References

None - Implementation completed without requiring debug logging.

### Completion Notes List

1. **Schema Implementation**: Successfully added `post_performance` table to `convex/schema.ts` with proper validators and indexes.

2. **Analytics Module**: Created comprehensive `convex/analytics.ts` with:
   - `fetchEngagementMetrics` action (stub implementation with feature flag check)
   - `storePerformanceData` mutation with duplicate handling
   - `scheduledMetricsFetch` internal action with rate limiting
   - `getPerformanceInsights` mutation for UI data aggregation
   - `getRecentPublishedPosts` internal query for scheduled fetching

3. **Recommendation Enhancement**: Enhanced `convex/recommendations.ts` with:
   - `getHistoricalPerformanceData` function to query user's performance data
   - `calculateHistoricalPerformanceFactor` function for score normalization
   - Integration into `getRecommendedTimes` query with 60/40 weighting (research/historical)

4. **Performance Insights UI**: Created:
   - `app/insights/page.tsx` with route protection
   - `components/features/PerformanceInsights.tsx` with platform/date range filters
   - Top performing times display
   - Hourly breakdown table
   - Feature-disabled and no-data states with setup instructions

5. **Feature Flag System**: Implemented throughout with `PERFORMANCE_TRACKING_ENABLED` environment variable checks in:
   - Analytics actions and queries
   - Recommendation algorithm
   - Performance Insights UI

6. **Documentation**: Created comprehensive `docs/features/performance-tracking.md` covering:
   - Twitter/X API setup with endpoints and credentials
   - LinkedIn API setup with OAuth scopes
   - Convex configuration with environment variables
   - Step-by-step activation guide
   - Rate limits and troubleshooting
   - API pricing information

7. **Testing**: Created comprehensive test suites:
   - `convex/analytics.test.ts` - Unit tests for schema, calculations, algorithms, and feature flags
   - `convex/analytics.integration.test.ts` - Integration tests for full workflows

8. **Route Protection**: Updated `middleware.ts` to protect `/insights` route with Clerk authentication.

9. **All Acceptance Criteria Met**:
   - AC1: `post_performance` table defined with proper structure
   - AC2: Convex action for fetching metrics (stub with feature flag)
   - AC3: Performance data storage mutation with validation
   - AC4: Historical weighting in recommendation algorithm
   - AC5: Performance Insights UI with filters and visualization
   - AC6: Feature remains inactive with `PERFORMANCE_TRACKING_ENABLED=false`
   - AC7: Comprehensive documentation in `docs/features/performance-tracking.md`

10. **Future Activation Notes**:
    - Create `convex/crons.ts` to schedule `scheduledMetricsFetch`
    - Add Twitter/LinkedIn API credentials to Convex environment variables
    - Set `PERFORMANCE_TRACKING_ENABLED=true` when ready
    - Test with sample posts before full deployment

### File List

**New Files:**

- `convex/analytics.ts` - Performance tracking backend logic
- `app/insights/page.tsx` - Performance Insights UI page
- `components/features/PerformanceInsights.tsx` - Performance Insights component
- `docs/features/performance-tracking.md` - API setup documentation
- `convex/analytics.test.ts` - Unit tests
- `convex/analytics.integration.test.ts` - Integration tests

**Modified Files:**

- `convex/schema.ts` - Added `post_performance` table
- `convex/recommendations.ts` - Enhanced with historical performance weighting
- `middleware.ts` - Added `/insights` to protected routes

## QA Results

_To be filled by QA agent_

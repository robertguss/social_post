# Story 5.2: Smart Content Pre-population (Twitter â†’ LinkedIn)

## Status

Draft

## Story

**As a** content creator,
**I want** LinkedIn content to be automatically pre-filled with my Twitter content,
**so that** I can easily expand the shorter Twitter version into a longer LinkedIn post.

## Acceptance Criteria

1. When the user finishes typing in the Twitter text field (2 second debounce), the system detects if LinkedIn field is empty.
2. If LinkedIn field is empty, a "Pre-fill LinkedIn" button appears above the LinkedIn text area.
3. Clicking "Pre-fill LinkedIn" copies the Twitter content exactly to the LinkedIn field.
4. Pre-population only occurs if the LinkedIn field is completely empty (not if it has content).
5. A visual indicator (e.g., "Pre-filled from Twitter") displays briefly after pre-population.
6. Users can manually clear or edit the LinkedIn content after pre-population without affecting Twitter content.
7. Pre-population can be disabled via user preferences/settings.

## Tasks / Subtasks

- [ ] **Task 1: Implement debounced change detection for Twitter field** (AC: 1)
  - [ ] In `DualPlatformTextFields.tsx` component (from Story 5.1), add `useEffect` hook to monitor `twitterContent` changes
  - [ ] Implement 2-second debounce using `setTimeout` or a debounce utility (consider `use-debounce` hook library)
  - [ ] On debounce trigger, check if `linkedInContent` is empty (empty string or only whitespace)
  - [ ] Update local state to show/hide "Pre-fill LinkedIn" button based on conditions

- [ ] **Task 2: Create and display "Pre-fill LinkedIn" button** (AC: 2, 4)
  - [ ] Add conditional button component above LinkedIn text area
  - [ ] Button should only display when:
    - Twitter field has content (non-empty after trim)
    - LinkedIn field is completely empty
  - [ ] Use shadcn/ui Button component with appropriate styling
  - [ ] Position button clearly above LinkedIn text area for easy discovery
  - [ ] Add icon (e.g., copy icon or arrow icon) to button for visual clarity

- [ ] **Task 3: Implement pre-fill functionality** (AC: 3, 6)
  - [ ] Create `handlePreFillLinkedIn` function in `DualPlatformTextFields.tsx`
  - [ ] Function should copy `twitterContent` value exactly to `linkedInContent`
  - [ ] Call `onLinkedInChange` callback prop with the copied Twitter content
  - [ ] Ensure LinkedIn text area receives focus after pre-fill for immediate editing
  - [ ] Verify that editing LinkedIn content after pre-fill doesn't affect Twitter content (independent state)

- [ ] **Task 4: Add visual feedback for successful pre-fill** (AC: 5)
  - [ ] Create toast/notification component using shadcn/ui Toast or similar
  - [ ] Display "Pre-filled from Twitter" message briefly (3-5 seconds) after pre-fill action
  - [ ] Alternatively, use inline temporary badge/label near LinkedIn text area
  - [ ] Ensure visual feedback is clear but not intrusive
  - [ ] Auto-dismiss the notification after timeout

- [ ] **Task 5: Implement user preference to disable pre-population** (AC: 7)
  - [ ] Create `user_preferences` table in Convex schema if it doesn't exist (check Story 6.5 schema)
  - [ ] Add `enableContentPrePopulation` field (boolean, default true) to user preferences
  - [ ] Create Convex query `getUserPreferences` to fetch user preferences
  - [ ] Create Convex mutation `updateUserPreferences` to update preferences
  - [ ] Add settings page UI element (toggle switch) for "Enable Smart Content Pre-fill" option
  - [ ] In `DualPlatformTextFields`, fetch user preference using `useQuery` hook
  - [ ] Only show "Pre-fill LinkedIn" button if user preference is enabled

- [ ] **Task 6: Add user preferences settings page/section** (AC: 7)
  - [ ] Create or update settings page component (e.g., `app/settings/page.tsx`)
  - [ ] Add "Content Creation" section with preference toggles
  - [ ] Include toggle for "Enable Smart Content Pre-fill" with description
  - [ ] Connect toggle to Convex mutation to save preference changes
  - [ ] Provide user feedback on save (toast notification)
  - [ ] Ensure settings page is accessible from main navigation

- [ ] **Task 7: Add unit and integration tests** (AC: 1-7)
  - [ ] Create test file `components/features/DualPlatformTextFields.test.tsx` (extend from Story 5.1)
  - [ ] Test: Debounced detection triggers after 2 seconds of inactivity in Twitter field
  - [ ] Test: "Pre-fill LinkedIn" button appears when Twitter has content and LinkedIn is empty
  - [ ] Test: Button does NOT appear when LinkedIn has content
  - [ ] Test: Clicking button copies Twitter content to LinkedIn field
  - [ ] Test: Visual feedback displays after pre-fill
  - [ ] Test: LinkedIn content remains independent after pre-fill
  - [ ] Test: Button respects user preference setting (doesn't show if disabled)
  - [ ] Integration test: Verify Convex mutations/queries for user preferences work correctly

## Dev Notes

### Previous Story Context

Story 5.1 created the `DualPlatformTextFields.tsx` component with separate, visually distinct text areas for Twitter and LinkedIn content. This story enhances that component with smart pre-population functionality to streamline the content creation workflow.

### Frontend Architecture

[Source: docs/architecture/frontend-architecture.md#Component Architecture]

- **Component Location**: Enhance existing `components/features/DualPlatformTextFields.tsx` from Story 5.1
- **UI Primitives**: Use shadcn/ui Button for pre-fill button, Toast for notifications, and Switch for settings toggle
- **State Management**: Use React `useState` for local button visibility state; use Convex `useQuery` to fetch user preferences
- **Convex Integration**: Fetch preferences via query, update via mutation

[Source: docs/architecture/frontend-architecture.md#State Management Architecture]

- **Global State (Data)**: User preferences stored in Convex, fetched via `useQuery`
- **Local UI State**: Button visibility, toast display, debounce timers managed with React hooks

### Tech Stack

[Source: docs/architecture/tech-stack.md]

- **Frontend Framework**: Next.js 15.5.4 (App Router), React 19
- **UI Component Library**: shadcn/ui - Use Button, Toast/Notification component
- **Styling**: Tailwind CSS 4
- **Backend**: Convex for user preferences storage and queries
- **Language**: TypeScript

### Data Models

[Source: docs/architecture/data-models.md]

**User Preferences Table** (to be created in `convex/schema.ts`):

The `user_preferences` table will store user-specific settings. This story adds the first preference field, but the table structure should support future preferences as well (referenced in Story 6.5).

Suggested schema:
```typescript
user_preferences: defineTable({
  clerkUserId: v.string(),
  enableContentPrePopulation: v.boolean(), // Default: true
  // Future preference fields can be added here
})
  .index("by_user", ["clerkUserId"])
```

### Convex Function Patterns

**Query for User Preferences**:
```typescript
// convex/userPreferences.ts
export const getUserPreferences = query({
  args: {},
  returns: v.union(v.null(), v.object({
    enableContentPrePopulation: v.boolean(),
    // other fields...
  })),
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const prefs = await ctx.db
      .query("user_preferences")
      .withIndex("by_user", (q) => q.eq("clerkUserId", identity.subject))
      .first();

    return prefs || null; // Return null if no preferences set yet
  },
});
```

**Mutation for Updating Preferences**:
```typescript
export const updateUserPreferences = mutation({
  args: {
    enableContentPrePopulation: v.optional(v.boolean()),
    // other fields as they're added...
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const existing = await ctx.db
      .query("user_preferences")
      .withIndex("by_user", (q) => q.eq("clerkUserId", identity.subject))
      .first();

    if (existing) {
      await ctx.db.patch(existing._id, args);
    } else {
      await ctx.db.insert("user_preferences", {
        clerkUserId: identity.subject,
        enableContentPrePopulation: args.enableContentPrePopulation ?? true,
      });
    }
  },
});
```

### Implementation Patterns

**Debounce Pattern**:
- Use `useEffect` with cleanup to implement debounce
- Consider using `use-debounce` library: `const debouncedTwitterContent = useDebounce(twitterContent, 2000);`
- On debounce trigger, check LinkedIn field state and update button visibility

**Conditional Button Rendering**:
```typescript
const shouldShowPreFillButton =
  twitterContent.trim().length > 0 &&
  linkedInContent.trim().length === 0 &&
  userPreferences?.enableContentPrePopulation !== false;

{shouldShowPreFillButton && (
  <Button onClick={handlePreFillLinkedIn}>
    Pre-fill LinkedIn
  </Button>
)}
```

**Toast Notification Pattern**:
- Use shadcn/ui Toast component (if available) or create simple inline notification
- Auto-dismiss after 3-5 seconds using `setTimeout`
- Position near the LinkedIn text area for contextual feedback

### Settings Page Integration

[Source: docs/architecture/frontend-architecture.md#Routing Architecture]

- Create settings route at `app/settings/page.tsx` (if it doesn't exist)
- Add link to settings in main navigation or user menu
- Structure settings page with sections: "Content Creation", "Notifications", etc.
- Use Card components from shadcn/ui to organize settings sections

### Testing

[Source: docs/architecture/testing-strategy.md#Unit Testing]

- **Test Level**: Unit tests for React component, Integration tests for Convex functions
- **Tools**: Jest with React Testing Library for component tests
- **Testing Focus**:
  - Debounce behavior (challenging - may need to mock timers)
  - Button visibility logic under different conditions
  - Pre-fill action and state updates
  - Toast notification display and dismissal
  - User preference integration

[Source: docs/architecture/testing-strategy.md#Integration Testing]

- Test Convex queries/mutations for user preferences
- Verify authentication flow in preference functions
- Test preference defaults when user has no preferences set

**Testing Requirements**:
- Test file location: Extend `components/features/DualPlatformTextFields.test.tsx` from Story 5.1
- Test debounced change detection using `jest.useFakeTimers()` and `jest.advanceTimersByTime(2000)`
- Test conditional button rendering based on field states and user preferences
- Mock Convex `useQuery` hook to simulate different preference states

### Accessibility Considerations

- Add `aria-label` to "Pre-fill LinkedIn" button: "Copy Twitter content to LinkedIn"
- Ensure toast notification is announced to screen readers (use `role="status"` or `aria-live="polite"`)
- Button should be keyboard accessible
- Provide clear visual feedback for all user actions

### Implementation Notes

1. **User Preference Default**: If user has no preference record, default to enabling pre-population (opt-out model for better UX).

2. **Whitespace Handling**: Check for empty LinkedIn field using `.trim()` to avoid false positives with whitespace-only content.

3. **Settings Page**: This story creates the initial user preferences infrastructure. Future stories (6.5, 7.x) will add more preference options to the same settings page.

4. **Independent State**: Ensure that after pre-fill, the two text areas remain independent. Editing LinkedIn should not affect Twitter content.

5. **Performance**: Debouncing prevents excessive re-renders and state checks. 2 seconds is a good balance between responsiveness and avoiding premature triggers.

6. **Button Positioning**: Place the "Pre-fill LinkedIn" button prominently but not intrusively - above the LinkedIn text area is ideal for discoverability.

## Change Log

| Date       | Version | Description                 | Author        |
| :--------- | :------ | :-------------------------- | :------------ |
| 2025-11-03 | 1.0     | Initial story draft created | Scrum Master  |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_

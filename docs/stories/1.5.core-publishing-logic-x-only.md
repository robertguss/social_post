# Story 1.5: Core Publishing Logic (X only)

## Status

Done

## Story

**As a** content creator,
**I want** my scheduled X/Twitter posts to be reliably published at the designated time,
**so that** my audience receives my content on schedule.

## Acceptance Criteria

1. A Convex Mutation successfully schedules an internal Convex Action upon form submission.
2. The internal Action is triggered within 30 seconds of the scheduled time.
3. The Action successfully retrieves the encrypted X token, decrypts it, and publishes the text post to the X API.
4. If a URL is provided, the Action posts the URL as a reply in the X thread.
5. The Action updates the post status to `Published` and stores the `twitterPostId`.
6. The Action implements auto-retry (2-3 attempts) for transient API failures.

## Tasks / Subtasks

- [x] **Task 1: Update createPost Mutation to Schedule Publishing Action** (AC: 1)
  - [x] Import `internal` API reference and `ctx.scheduler` in `convex/posts.ts`
  - [x] After creating the post record, call `ctx.scheduler.runAt()` with `twitterScheduledTime` and `internal.publishing.publishTwitterPost` action
  - [x] Pass `postId` as an argument to the scheduled action
  - [x] Add error handling for scheduler failures
  - [x] Test mutation to verify scheduler is invoked correctly

- [x] **Task 2: Create Publishing Action File and Initial Structure** (AC: 2, 3)
  - [x] Create new file: `convex/publishing.ts` with `"use node";` directive
  - [x] Import required dependencies: `internalAction`, `internal`, `v`, Node.js `fetch`
  - [x] Define `publishTwitterPost` as an `internalAction` with args: `postId: v.id("posts")`
  - [x] Implement auth-free action handler (internal actions don't require user auth)
  - [x] Add structured error handling and logging

- [x] **Task 3: Retrieve and Decrypt OAuth Tokens** (AC: 3)
  - [x] Within `publishTwitterPost` action, query `posts` table to get post record by ID
  - [x] Verify post exists and status is "Scheduled"
  - [x] Update post status to "Publishing" to prevent duplicate publishing
  - [x] Query `user_connections` table using `by_user_platform` index with `clerkUserId` and `platform: "twitter"`
  - [x] Call `internal.encryption.decrypt` action to decrypt `accessToken`
  - [x] Handle decryption errors and update post status to "Failed" if decryption fails
  - [x] Store decrypted token securely in memory (never log it)

- [x] **Task 4: Publish Text Post to X API** (AC: 3)
  - [x] Construct X API v2 POST request to `/2/tweets` endpoint
  - [x] Set headers: `Authorization: Bearer {decryptedToken}`, `Content-Type: application/json`
  - [x] Set body: `{ "text": post.twitterContent }`
  - [x] Execute fetch request with timeout (30 seconds)
  - [x] Parse response JSON and extract `data.id` (the tweet ID)
  - [x] Handle API errors: rate limits (429), auth failures (401/403), server errors (5xx)
  - [x] Store tweet ID for use in URL threading (next task)

- [x] **Task 5: Post URL as Reply Thread (If Provided)** (AC: 4)
  - [x] Check if `post.url` field is not empty
  - [x] If URL exists, construct second X API POST request to `/2/tweets`
  - [x] Set body: `{ "text": post.url, "reply": { "in_reply_to_tweet_id": tweetId } }`
  - [x] Execute fetch request with same headers and timeout
  - [x] Handle API errors (same error types as Task 4)
  - [x] Log success or failure of URL reply posting

- [x] **Task 6: Update Post Status to Published** (AC: 5)
  - [x] Call internal mutation `internal.posts.updatePostStatus` to update the post record
  - [x] Set `status: "Published"`, `twitterPostId: tweetId`, `errorMessage: undefined`
  - [x] Create the `updatePostStatus` internal mutation in `convex/posts.ts`
  - [x] Mutation args: `postId: v.id("posts")`, `status: v.string()`, `twitterPostId: v.optional(v.string())`, `errorMessage: v.optional(v.string())`
  - [x] Verify mutation updates the correct post record

- [x] **Task 7: Implement Auto-Retry Logic for Transient Failures** (AC: 6)
  - [x] Wrap publishing logic in try-catch block
  - [x] On error, check if error is transient (rate limit, network error, 5xx server error)
  - [x] Increment `retryCount` field in post record (initialize to 0 if undefined)
  - [x] If `retryCount < 3`, schedule a retry action using `ctx.scheduler.runAfter()` with exponential backoff (2^retryCount minutes)
  - [x] If `retryCount >= 3`, mark post as "Failed" and store error message
  - [x] Update `updatePostStatus` mutation to handle `retryCount` updates
  - [x] Test retry logic with simulated API failures

- [x] **Task 8: Handle Final Failure (After Max Retries)** (AC: 6, NFR4)
  - [x] When `retryCount >= 3`, update post status to "Failed"
  - [x] Store final error message in `errorMessage` field
  - [x] Create stub for Telegram notification action: `internal.notifications.sendFailureNotification`
  - [x] Call Telegram notification action with post details (to be implemented in future story)
  - [x] Add TODO comment noting Telegram implementation is pending
  - [x] Log final failure for debugging

- [x] **Task 9: Unit Testing for Publishing Logic** (AC: 3, 4, 5, 6)
  - [x] Create test file: `__tests__/convex/publishing.test.ts`
  - [x] Mock X API responses (success, 401, 429, 500)
  - [x] Mock Convex actions (decrypt, updatePostStatus)
  - [x] Write test: successful post publication updates status to "Published"
  - [x] Write test: successful URL threading creates reply tweet
  - [x] Write test: token decryption failure marks post as "Failed"
  - [x] Write test: transient API error (429, 5xx) triggers retry with exponential backoff
  - [x] Write test: final retry failure (retryCount >= 3) marks post as "Failed" and calls notification
  - [x] Write test: scheduler is invoked correctly in `createPost` mutation
  - [x] Ensure all tests pass

- [x] **Task 10: Integration Testing for End-to-End Publishing Flow** (AC: 1, 2, 3, 4, 5, 6)
  - [x] Create test file: `__tests__/integration/publishing-flow.test.ts`
  - [x] Mock Convex scheduler, database, and external APIs
  - [x] Write test: creating post schedules publishing action at correct time
  - [x] Write test: scheduled action publishes to X within 30 seconds of scheduled time
  - [x] Write test: post status progresses correctly: Scheduled → Publishing → Published
  - [x] Write test: retry mechanism works for transient failures
  - [x] Write test: final failure after max retries updates status and triggers notification
  - [x] Mock time advancement for scheduler testing
  - [x] Ensure all integration tests pass

## Dev Notes

### Architecture Context

This story implements the **core publishing engine** of the Social Posting Scheduler. The publishing logic is the most critical component of the system, responsible for reliably publishing posts at scheduled times with auto-retry capabilities for transient failures.

The architecture follows Convex's **Scheduled Actions** pattern, where:

1. A mutation schedules an internal action to run at a specific time
2. The internal action executes at the scheduled time (within 30 seconds accuracy)
3. The action calls external APIs (X/Twitter) and updates post status

[Source: docs/architecture/high-level-architecture.md#high-level-architecture-diagram]

### Previous Story Insights

From Story 1.4:

- The `createPost` mutation in `convex/posts.ts` creates post records with status "Scheduled"
- A TODO comment was added noting that scheduling logic needs to be implemented
- The mutation validates content (max 280 chars) and scheduled time (must be future)
- Post records include `twitterScheduledTime`, `url`, and `retryCount` fields

From Story 1.3:

- Encryption utilities are available in `convex/encryption.ts` with `encrypt` and `decrypt` internal actions
- `decrypt` action takes `ciphertext: v.string()` and returns plaintext string
- Encryption keys are stored in Convex Environment Variables as `ENCRYPTION_KEY`
- OAuth tokens in `user_connections` table are already encrypted

From Story 1.2:

- X/Twitter OAuth tokens are stored in `user_connections` table with `platform: "twitter"`
- The `by_user_platform` index enables efficient lookup: `["clerkUserId", "platform"]`
- Tokens include `accessToken`, `refreshToken`, and `expiresAt` fields

[Source: docs/stories/1.4.post-creation-form-x-focus.md#dev-agent-record]
[Source: docs/stories/1.3.secure-token-encryption-storage.md#dev-agent-record]
[Source: docs/stories/1.2.secure-x-twitter-oauth-integration.md#dev-agent-record]

### Tech Stack Details

**Backend:**

- **Database/Functions**: Convex ^1.28.0
- **Scheduled Functions**: Convex's `ctx.scheduler.runAt(timestamp, action, args)` API
- **Actions**: Node.js runtime with `"use node";` directive for external API calls
- **API Style**: Internal Actions for publishing logic (not exposed to client)

**External API:**

- **X/Twitter API v2**: `/2/tweets` endpoint for posting tweets
- **Authentication**: OAuth 2.0 Bearer token in `Authorization` header
- **Rate Limits**: 200 tweets per 15 minutes (user context)

[Source: docs/architecture/tech-stack.md]

### Data Models

#### `posts` Table

**Fields Used in This Story:**

- `clerkUserId`: string (Clerk user ID - used to query user_connections)
- `status`: string (states: "Scheduled" → "Publishing" → "Published" or "Failed")
- `twitterContent`: string (the tweet text to publish)
- `twitterScheduledTime`: number (UTC timestamp when action should run)
- `url`: string (optional - posted as reply if provided)
- `errorMessage`: string (optional - stores error details on failure)
- `retryCount`: number (optional - tracks retry attempts, max 3)
- `twitterPostId`: string (optional - stores tweet ID after successful publish)

**Index:** `by_user` on `["clerkUserId"]` - used to verify post ownership

[Source: docs/architecture/data-models.md]
[Source: convex/schema.ts]

#### `user_connections` Table

**Fields Used in This Story:**

- `clerkUserId`: string (matches post.clerkUserId)
- `platform`: string (must be "twitter" for this story)
- `accessToken`: string (encrypted - must decrypt before use)
- `refreshToken`: string (encrypted - not used in this story, token refresh in future)
- `expiresAt`: number (timestamp - not validated in this story, token refresh in future)

**Index:** `by_user_platform` on `["clerkUserId", "platform"]` - enables fast token lookup

[Source: docs/architecture/data-models.md]
[Source: convex/schema.ts]

### Convex Scheduled Actions Architecture

**Scheduling Pattern:**

The `createPost` mutation must schedule the publishing action using `ctx.scheduler.runAt()`:

```typescript
import { internal } from "./_generated/api";

export const createPost = mutation({
  // ... existing args and validation ...
  handler: async (ctx, args) => {
    // ... existing post creation logic ...
    const postId = await ctx.db.insert("posts", {
      /* ... */
    });

    // Schedule the publishing action
    await ctx.scheduler.runAt(
      args.scheduledTime, // UTC timestamp
      internal.publishing.publishTwitterPost,
      { postId },
    );

    return postId;
  },
});
```

**Key Points:**

- `runAt()` schedules an action to run at a specific timestamp
- Accuracy: Within 30 seconds of scheduled time (meets NFR2 requirement)
- The action reference must be an `internal` action (not exposed to client)
- Arguments are passed as an object

[Source: CLAUDE.md#scheduling-posts-critical-pattern]

### Internal Actions Pattern

Publishing logic must use `internalAction` (not `action`) to prevent direct client access:

```typescript
"use node";

import { internalAction } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";

export const publishTwitterPost = internalAction({
  args: { postId: v.id("posts") },
  handler: async (ctx, args) => {
    // Internal actions can:
    // 1. Use Node.js APIs (fetch, crypto, etc.) via "use node"
    // 2. Access environment variables (process.env.TWITTER_API_KEY)
    // 3. Call other internal actions: ctx.runAction(internal.encryption.decrypt, {...})
    // 4. Call internal mutations: ctx.runMutation(internal.posts.updatePostStatus, {...})
    // 5. Query database: ctx.runQuery(internal.posts.getPostById, {...})
    // Internal actions do NOT:
    // 1. Verify user authentication (they're server-side only)
    // 2. Use ctx.db directly (must use ctx.runQuery/ctx.runMutation)
  },
});
```

[Source: CLAUDE.md#calling-external-apis-actions-only]

### X/Twitter API Integration

**API Endpoint:**

- Base URL: `https://api.twitter.com`
- Post Tweet: `POST /2/tweets`
- Documentation: <https://developer.twitter.com/en/docs/twitter-api/tweets/manage-tweets/api-reference/post-tweets>

**Authentication:**

```typescript
headers: {
  "Authorization": `Bearer ${decryptedAccessToken}`,
  "Content-Type": "application/json"
}
```

**Request Body (Text Post):**

```json
{
  "text": "Tweet content here (max 280 chars)"
}
```

**Request Body (Reply/Thread):**

```json
{
  "text": "Reply content or URL",
  "reply": {
    "in_reply_to_tweet_id": "1234567890"
  }
}
```

**Response (Success - 201 Created):**

```json
{
  "data": {
    "id": "1234567890",
    "text": "Tweet content here"
  }
}
```

**Error Responses:**

- `401 Unauthorized`: Invalid or expired token (permanent failure)
- `403 Forbidden`: Permission issue or suspended account (permanent failure)
- `429 Too Many Requests`: Rate limit exceeded (transient - retry after delay)
- `500/502/503 Server Error`: X API issues (transient - retry)

**Rate Limiting:**

- User context: 200 tweets per 15 minutes
- App context: Not applicable (using user OAuth tokens)
- Retry strategy: Exponential backoff (2^retryCount minutes)

[Source: CLAUDE.md#external-api-integration]
[Source: docs/prd/2-requirements.md#non-functional - NFR4]

### Retry Logic and Error Handling

**Retry Strategy:**

```typescript
const MAX_RETRIES = 3;

// Determine if error is transient
function isTransientError(error: any): boolean {
  const status = error.status || error.response?.status;

  // Transient errors that should trigger retry:
  // - 429 Rate Limit
  // - 5xx Server Errors (500, 502, 503, 504)
  // - Network errors (ECONNRESET, ETIMEDOUT, etc.)
  return (
    status === 429 ||
    (status >= 500 && status < 600) ||
    error.code === "ECONNRESET"
  );
}

// Exponential backoff calculation
function getRetryDelay(retryCount: number): number {
  // 2^0 = 1 minute, 2^1 = 2 minutes, 2^2 = 4 minutes
  return Math.pow(2, retryCount) * 60 * 1000; // Convert to milliseconds
}

// Retry scheduling
if (isTransientError(error) && retryCount < MAX_RETRIES) {
  await ctx.scheduler.runAfter(
    getRetryDelay(retryCount),
    internal.publishing.publishTwitterPost,
    { postId: args.postId },
  );
}
```

**Error State Machine:**

1. **Scheduled** → (scheduler triggers) → **Publishing**
2. **Publishing** → (success) → **Published**
3. **Publishing** → (transient error, retryCount < 3) → **Scheduled** (retry after delay)
4. **Publishing** → (permanent error OR retryCount >= 3) → **Failed**

**Error Message Storage:**

- Store descriptive error message in `post.errorMessage` field
- Include error type, status code, and API response details
- Never log OAuth tokens or encryption keys
- Format: `"X API Error 429: Rate limit exceeded. Retry attempt 2/3"`

[Source: docs/architecture/testing-strategy.md#error-handling-strategy]
[Source: docs/prd/2-requirements.md#non-functional - NFR4]

### File Locations

Based on project repository structure:

**New Files to Create:**

- `convex/publishing.ts` - Publishing action for X/Twitter posts
- `convex/notifications.ts` - Stub for Telegram failure notifications (minimal implementation)
- `__tests__/convex/publishing.test.ts` - Unit tests for publishing logic
- `__tests__/integration/publishing-flow.test.ts` - Integration tests for end-to-end flow

**Files to Modify:**

- `convex/posts.ts` - Update `createPost` mutation to schedule action, add `updatePostStatus` internal mutation

[Source: docs/architecture/high-level-architecture.md#repository-structure]

### Project Structure Notes

The repository structure aligns with the architecture specification. Publishing logic belongs in `convex/` directory as it's backend server logic. The use of `internal` actions ensures publishing logic is not exposed to the client, maintaining security.

No structural conflicts identified.

### Security Considerations

**Critical Security Requirements:**

1. **Never Log Secrets:**
   - Do NOT log decrypted OAuth tokens
   - Do NOT log encryption keys
   - Do NOT include tokens in error messages
   - Only log sanitized error info (status codes, error types)

2. **Token Handling:**
   - Decrypt tokens only when needed (just before API call)
   - Store decrypted token in memory only (never persist)
   - Clear token from memory after use (JavaScript garbage collection)

3. **Internal Actions Only:**
   - Publishing logic MUST use `internalAction` (not public `action`)
   - Prevents unauthorized client access to publishing endpoint
   - Scheduler can only invoke internal actions (security by design)

4. **Error Messages:**
   - Client-facing error messages must be sanitized
   - Never expose internal implementation details
   - Format: "Post failed to publish. Please check your connection status."

[Source: docs/architecture/security.md]
[Source: CLAUDE.md#security-requirements]

### Performance Requirements

**NFR2: Post publishing must be triggered within 30 seconds of the scheduled time.**

Convex's `scheduler.runAt()` guarantees execution within this window. The publishing action should complete quickly:

- Token decryption: <100ms
- X API call (text post): <2 seconds
- X API call (URL reply): <2 seconds
- Database updates: <100ms
- **Total estimated time: <5 seconds** (well under 30-second SLA)

**Timeout Configuration:**

- Set fetch timeout to 30 seconds to prevent hanging
- If API call exceeds timeout, treat as transient error and retry

[Source: docs/prd/2-requirements.md#non-functional - NFR2]

### Environment Variables Required

The publishing action requires the following environment variables (configured in Convex Dashboard):

- `ENCRYPTION_KEY`: AES-256 encryption key (base64-encoded, 32 bytes) - Already configured in Story 1.3
- No additional X API credentials needed - using user's OAuth tokens from `user_connections`

[Source: docs/architecture/security.md#encryption-key-management]

## Testing

### Testing Standards

**Test Levels Required:**

1. **Unit Tests:**
   - Framework: Jest (already configured from Story 1.1)
   - Focus Areas:
     - Token decryption and retrieval logic
     - X API request construction (headers, body, endpoint)
     - Retry logic (transient vs permanent error detection)
     - Exponential backoff calculation
     - Error state transitions (Scheduled → Publishing → Published/Failed)
   - Location: `__tests__/convex/publishing.test.ts`
   - Mocking: Mock `fetch`, `ctx.runAction`, `ctx.runMutation`, `ctx.runQuery`, `ctx.scheduler`

2. **Integration Tests:**
   - Framework: Jest with Convex testing utilities
   - Focus Areas:
     - End-to-end publishing flow (createPost → scheduler → publishTwitterPost → status update)
     - Post status transitions through the complete lifecycle
     - Retry mechanism with simulated time advancement
     - Final failure handling and notification trigger
     - URL threading logic (main tweet + reply)
   - Location: `__tests__/integration/publishing-flow.test.ts`
   - Mocking: Mock external APIs (X API), mock Convex scheduler for time control

3. **Action Testing:**
   - Focus Areas:
     - API contract adherence (correct request format for X API v2)
     - Rate limit handling (429 response triggers retry)
     - Auto-retry logic (exponential backoff timing)
     - Telegram notification trigger on final failure (stub verification)
   - Included in unit tests for `publishing.ts`

[Source: docs/architecture/testing-strategy.md]

### Error Handling for This Story

**Publishing Action Layer (Most Critical):**

1. **Capture HTTP errors** from X API (status codes, response bodies)
2. **Classify errors** as transient (429, 5xx, network) or permanent (401, 403, 400)
3. **Transient errors:** Increment `retryCount`, schedule retry with exponential backoff
4. **Permanent errors OR max retries:** Update status to "Failed", store error message, trigger Telegram notification stub
5. **Token decryption errors:** Mark post as "Failed" with descriptive error message

**Client/UI Layer:**

- Display post status in real-time (Convex reactive queries)
- Show error message from `post.errorMessage` for failed posts
- (UI implementation is in future Story 1.6 - this story focuses on backend only)

[Source: docs/architecture/testing-strategy.md#error-handling-strategy]

### Test Coverage Requirements

- All error classification logic must be tested (transient vs permanent)
- Retry scheduling must be tested with various retry counts (0, 1, 2, 3)
- Exponential backoff calculation must be verified (1min, 2min, 4min)
- Token decryption failure must be tested
- X API success and failure responses must be mocked and tested
- URL threading logic must be tested (with and without URL)
- Status transitions must be verified: Scheduled → Publishing → Published/Failed
- Scheduler invocation must be tested in `createPost` mutation
- Final failure notification trigger must be verified (stub call)

## Change Log

| Date       | Version | Description                                 | Author           |
| :--------- | :------ | :------------------------------------------ | :--------------- |
| 2025-10-30 | 1.0     | Initial story creation (Draft)              | Scrum Master Bob |
| 2025-10-30 | 2.0     | Implementation completed - Ready for Review | Dev Agent James  |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

None - No blocking issues encountered during implementation

### Completion Notes List

- **Publishing Architecture**: Implemented complete publishing workflow using Convex scheduled actions with `ctx.scheduler.runAt()` for time-based publishing and `ctx.scheduler.runAfter()` for retry scheduling
- **Token Security**: Utilized existing `internal.connections.getDecryptedConnection` action for secure token retrieval - tokens are decrypted only when needed and stored in memory only during the publishing action
- **Error Handling**: Implemented robust error classification system distinguishing transient errors (429 rate limit, 5xx server errors, network timeouts) from permanent errors (401 unauthorized, 403 forbidden, 400 bad request)
- **Retry Logic**: Exponential backoff implemented with formula `2^retryCount * 60 * 1000ms` resulting in 1min, 2min, 4min delays for retries 1, 2, and 3 respectively
- **URL Threading**: URL reply posting implemented as separate API call with error handling that doesn't fail the main post if URL posting fails
- **Post Status Lifecycle**: Implemented state machine: `Scheduled → Publishing → Published` (success) or `Scheduled → Publishing → Scheduled` (retry) or `Scheduled → Publishing → Failed` (permanent error or max retries)
- **Notifications Stub**: Created `convex/notifications.ts` with stub `sendFailureNotification` action for future Telegram integration
- **Testing Coverage**: 106 total tests passing (added 25 unit tests and 18 integration tests for publishing logic)
- **X API Integration**: Implemented proper X API v2 integration with `/2/tweets` endpoint, correct headers, request body format, and response parsing

### File List

**New Files Created:**

- `convex/publishing.ts` - Core publishing action for X/Twitter with retry logic and error handling
- `convex/notifications.ts` - Stub for Telegram failure notifications
- `__tests__/convex/publishing.test.ts` - Unit tests for publishing logic (25 tests)
- `__tests__/integration/publishing-flow.test.ts` - Integration tests for end-to-end flow (18 tests)

**Modified Files:**

- `convex/posts.ts` - Added scheduler invocation to `createPost` mutation, added `updatePostStatus` internal mutation, added `getPostById` internal query

## QA Results

To be completed by QA Agent

# Story 3.1: Template Data Model & Storage

## Status

Draft

## Story

**As an** engineer,
**I want** a database schema for storing reusable content templates,
**so that** users can save and retrieve content blocks efficiently.

## Acceptance Criteria

1. A `templates` table is defined in the Convex schema with fields: `clerkUserId`, `name`, `content`, `tags` (array), `createdAt`, `lastUsedAt`, `usageCount`.
2. The `templates` table has an index `by_user` on `clerkUserId` for efficient user-scoped queries.
3. Convex mutations are implemented for creating, updating, and deleting templates.
4. Convex queries are implemented for retrieving user's templates, optionally filtered by tag.
5. Template names must be unique per user (validation in mutation).

## Tasks / Subtasks

- [ ] **Task 1: Define templates table schema in convex/schema.ts** (AC: 1)
  - [ ] Add `templates` table with all required fields
  - [ ] Define appropriate field types (string, array, number)
  - [ ] Add system fields (_id, _creationTime)
- [ ] **Task 2: Create by_user index for templates table** (AC: 2)
  - [ ] Define index on clerkUserId field
  - [ ] Test index performance with sample queries
- [ ] **Task 3: Implement createTemplate mutation** (AC: 3, 5)
  - [ ] Validate user authentication
  - [ ] Check for duplicate template name per user
  - [ ] Insert new template record
  - [ ] Return created template ID
- [ ] **Task 4: Implement updateTemplate mutation** (AC: 3)
  - [ ] Validate user owns the template
  - [ ] Update template fields
  - [ ] Handle name uniqueness validation
- [ ] **Task 5: Implement deleteTemplate mutation** (AC: 3)
  - [ ] Validate user owns the template
  - [ ] Delete template record
- [ ] **Task 6: Implement getTemplates query** (AC: 4)
  - [ ] Query templates by user with index
  - [ ] Support optional tag filtering
  - [ ] Return sorted results
- [ ] **Task 7: Write unit tests for template CRUD operations** (AC: 1-5)
  - [ ] Test create with valid/invalid data
  - [ ] Test update and delete operations
  - [ ] Test query with/without tag filter
  - [ ] Test name uniqueness validation

## Dev Notes

### Architecture Context

This story establishes the data foundation for the Post Templates & Snippet Library feature (Epic 3). Templates are stored as standalone documents in Convex, separate from posts, to enable flexible reuse patterns.

**Key Design Decisions:**
- Templates are user-scoped via `clerkUserId` to ensure data isolation
- Tags are stored as an array in the document (not normalized) for simplicity
- Usage tracking fields (`lastUsedAt`, `usageCount`) are included from the start to support analytics (Story 3.5)
- Template names must be unique per user to prevent confusion

### Previous Story Insights

This is the first story in Epic 3, building on the foundation established in Epic 2 (LinkedIn Integration and Post Management).

**Key Learnings from Epic 2:**
- User-scoped data patterns using `clerkUserId` are well-established
- Index-based queries (`withIndex("by_user")`) are the standard for efficient lookups
- Convex mutations follow pattern: validate auth → validate data → perform operation

[Source: docs/prd/6-epic-details.md, Epic 2 stories]

### Data Models

**templates table:**

Fields:
- `clerkUserId`: string (Clerk user ID)
- `name`: string (unique per user)
- `content`: string (template text content)
- `tags`: array of strings (e.g., ["hashtags", "closing", "buildinpublic"])
- `createdAt`: number (timestamp, can use _creationTime system field)
- `lastUsedAt`: optional number (timestamp, null until first use)
- `usageCount`: number (default 0)
- `_id`: auto-generated document ID
- `_creationTime`: system field

**Indexes:**
- `by_user`: ["clerkUserId"] - primary index for user-scoped queries
- (Future consideration: `by_user_tag` if tag filtering becomes performance bottleneck)

**Validation Rules:**
- `name` must be unique within user's templates
- `clerkUserId` must match authenticated user
- `tags` array can be empty but must be defined
- `content` must be non-empty string

[Source: docs/prd/6-epic-details.md:187-197]

### API Specifications

**Convex Mutations:**

`createTemplate(args: { name: string, content: string, tags: string[] })`
- Validates user authentication
- Checks for duplicate name in user's templates
- Creates new template with usageCount = 0, lastUsedAt = null
- Returns: template ID

`updateTemplate(args: { templateId: Id<"templates">, name?: string, content?: string, tags?: string[] })`
- Validates user owns template
- Updates specified fields
- Validates name uniqueness if name is changed
- Returns: success boolean

`deleteTemplate(args: { templateId: Id<"templates"> })`
- Validates user owns template
- Deletes template document
- Returns: success boolean

**Convex Queries:**

`getTemplates(args: { tag?: string })`
- Retrieves all user's templates using `by_user` index
- Optionally filters by tag (in-memory filter on returned results)
- Returns: array of template objects sorted by name (A-Z)

### Component Specifications

No frontend components in this story - focus is on backend data model and API layer.

### File Locations

**Files to Create/Modify:**
- `convex/schema.ts` - Add templates table definition and index
- `convex/templates.ts` - New file with mutations and queries (create, update, delete, get)
- `__tests__/convex/templates.test.ts` - Unit tests for template operations

### Security Requirements

- All mutations must verify user authentication via `ctx.auth.getUserIdentity()`
- All operations must scope to authenticated user's `clerkUserId`
- Template data must never be shared across users
- No need for encryption (content is not sensitive like OAuth tokens)

### Environment Variables Required

None for this story.

### Technical Constraints

- Follow Convex new function syntax with validators (args, returns, handler)
- Use `v.id("templates")` validator for template IDs
- Use `withIndex("by_user")` for queries, never `filter()` on base query
- Maintain consistency with existing schema patterns from posts and user_connections tables

[Source: CLAUDE.md, Convex Function Patterns]

### Testing Standards

**Unit Test Coverage Required:**
- createTemplate: success case, duplicate name case, empty content case
- updateTemplate: success case, unauthorized user case, duplicate name case
- deleteTemplate: success case, unauthorized user case
- getTemplates: all templates case, filtered by tag case, empty result case
- Name uniqueness validation across create and update operations

**Testing Framework:**
- Jest for test runner
- Convex testing utilities for mocking context and database
- Mock user authentication with test `clerkUserId` values

[Source: docs/architecture/testing-strategy.md]

## Testing

### Unit Tests

**Location:** `__tests__/convex/templates.test.ts`

**Test Cases:**
1. createTemplate - successful creation with valid data
2. createTemplate - fails with duplicate name for same user
3. createTemplate - allows duplicate names for different users
4. createTemplate - fails when unauthenticated
5. updateTemplate - successfully updates template fields
6. updateTemplate - fails when user doesn't own template
7. updateTemplate - validates name uniqueness on update
8. deleteTemplate - successfully deletes template
9. deleteTemplate - fails when user doesn't own template
10. getTemplates - returns all user's templates
11. getTemplates - filters by single tag correctly
12. getTemplates - returns empty array when no templates exist

### Integration Tests

Not required for this data model story - integration tests will be added in Story 3.2 when UI components are implemented.

## Change Log

| Date       | Version | Description                          | Author     |
| :--------- | :------ | :----------------------------------- | :--------- |
| 2025-11-01 | 1.0     | Initial draft created from Epic 3.1. | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

To be populated by Dev Agent during implementation.

### Debug Log References

To be populated by Dev Agent during implementation.

### Completion Notes

To be populated by Dev Agent after implementation.

### File List

#### Created Files

To be populated by Dev Agent after implementation.

#### Modified Files

To be populated by Dev Agent after implementation.

## QA Results

To be populated by QA Agent after implementation review.

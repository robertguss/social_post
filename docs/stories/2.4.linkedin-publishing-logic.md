# Story 2.4: LinkedIn Publishing Logic

## Status

Done

## Story

**As a** content creator,
**I want** my scheduled LinkedIn posts to be reliably published at the designated time,
**so that** my professional audience receives my content on schedule.

## Acceptance Criteria

1. A Convex Mutation schedules a separate internal Action for LinkedIn publishing when a LinkedIn post is scheduled.
2. The LinkedIn publishing Action is triggered within 30 seconds of the scheduled time.
3. The Action successfully retrieves the encrypted LinkedIn token, decrypts it, and publishes the text post to the LinkedIn API (v2 UGC Posts).
4. If a URL is provided, the Action posts the URL as the first comment on the LinkedIn post.
5. The Action updates the post status to `Published` for LinkedIn and stores the `linkedInPostId`.
6. The Action implements auto-retry (2-3 attempts) for transient API failures with exponential backoff.
7. Failed LinkedIn posts trigger a Telegram notification similar to X/Twitter failures.

## Tasks / Subtasks

- [x] **Task 1: Uncomment LinkedIn Scheduling in createPost Mutation** (AC: 1)
  - [x] Open `convex/posts.ts` and locate the `createPost` mutation
  - [x] Uncomment lines 102-106 to enable LinkedIn post scheduling
  - [x] Verify scheduling call references `internal.publishing.publishLinkedInPost`
  - [x] Test mutation schedules LinkedIn action when `linkedInScheduledTime` is provided

- [x] **Task 2: Implement LinkedIn Publishing Action** (AC: 2, 3)
  - [x] Create `publishLinkedInPost` internal action in `convex/publishing.ts`
  - [x] Add `"use node"` directive at top of function block if needed
  - [x] Implement workflow: Retrieve post → Update to "Publishing" → Get decrypted tokens
  - [x] Add LinkedIn API constants: `LINKEDIN_API_BASE_URL = "https://api.linkedin.com"`
  - [x] Implement `publishLinkedInUGCPost()` helper function to call LinkedIn v2 UGC Posts API
  - [x] Use OAuth2 Bearer token authentication with decrypted LinkedIn access token
  - [x] Construct UGC Post request body per LinkedIn API spec (text content, visibility: PUBLIC)
  - [x] Extract LinkedIn post URN/ID from successful API response
  - [x] Handle API timeouts (30 seconds) using AbortController pattern
  - [x] Update post status to "Published" with `linkedInPostId` on success

- [x] **Task 3: Implement LinkedIn Comment Posting for URLs** (AC: 4)
  - [x] Create `publishLinkedInComment()` helper function in `convex/publishing.ts`
  - [x] Accept parameters: access token, URL text, parent post URN
  - [x] Call LinkedIn UGC API to post comment as first comment on the parent post
  - [x] Use same authentication and timeout patterns as main post publishing
  - [x] Handle comment posting errors gracefully (log but don't fail entire post)
  - [x] Integrate comment posting into main `publishLinkedInPost` action workflow

- [x] **Task 4: Implement Error Handling and Retry Logic** (AC: 6)
  - [x] Create `handleLinkedInPublishingError()` function similar to Twitter pattern
  - [x] Classify transient errors: 429 Rate Limit, 5xx Server Errors, network timeouts
  - [x] Classify permanent errors: 401 Unauthorized, 403 Forbidden, 400 Bad Request
  - [x] Implement exponential backoff retry delays: 1 min, 2 min, 4 min
  - [x] Update retry count and reschedule action for transient errors (max 3 attempts)
  - [x] Mark post as "Failed" after max retries or permanent errors
  - [x] Create `LinkedInApiError` custom error class with status code

- [x] **Task 5: Implement Telegram Failure Notification for LinkedIn** (AC: 7)
  - [x] Update `convex/notifications.ts` to support LinkedIn notifications
  - [x] Modify `sendFailureNotification` to accept optional `platform` parameter
  - [x] Update notification message format to indicate LinkedIn vs Twitter failures
  - [x] Use `linkedInContent` and `linkedInScheduledTime` for LinkedIn posts
  - [x] Call notification action from LinkedIn error handler on final failure
  - [x] Test notification triggers correctly for LinkedIn failures

- [x] **Task 6: Update Post Status Mutation for LinkedIn Fields** (AC: 5)
  - [x] Update `updatePostStatus` mutation args to include `linkedInPostId` parameter
  - [x] Add `linkedInPostId` to update object when provided
  - [x] Ensure mutation handles both Twitter and LinkedIn post ID updates independently
  - [x] Test mutation correctly stores LinkedIn post ID without affecting Twitter fields

- [x] **Task 7: Token Refresh Integration** (AC: 3)
  - [x] Check token expiration before publishing (compare `expiresAt` to current time)
  - [x] Call `internal.connections.refreshLinkedInToken` if token expires within 7 days
  - [x] Handle refresh failures: If `needsReauth: true`, update post to Failed with clear message
  - [x] Retry publishing after successful token refresh
  - [x] Add logging for token refresh operations

- [x] **Task 8: Write Unit Tests for LinkedIn Publishing** (AC: All)
  - [x] Test `publishLinkedInPost` action with mocked LinkedIn API
  - [x] Test successful post publishing flow (text-only and text+URL)
  - [x] Test retry logic for transient errors (429, 5xx)
  - [x] Test permanent error handling (401, 400)
  - [x] Test Telegram notification triggering on final failure
  - [x] Test token refresh integration
  - [x] Verify post status transitions: Scheduled → Publishing → Published/Failed

## Dev Notes

### Previous Story Insights

**Key Learnings from Story 2.3 (Dual Platform Post Creation Form):**

- LinkedIn scheduling action call is prepared but commented out in `convex/posts.ts` lines 98-107
- The `createPost` mutation correctly schedules both Twitter and LinkedIn actions when both platforms are selected
- Post schema already supports `linkedInContent`, `linkedInScheduledTime`, and `linkedInPostId` fields
- Existing Twitter publishing pattern in `convex/publishing.ts` should be used as template for LinkedIn implementation

[Source: docs/stories/2.3.dual-platform-post-creation-form.md#Dev-Agent-Record]

### Data Models

**posts table:**

- `clerkUserId`: string (Clerk ID)
- `status`: string ("Scheduled" | "Publishing" | "Published" | "Failed")
- `linkedInContent`: optional string (max 3,000 chars)
- `linkedInScheduledTime`: optional number (UTC timestamp)
- `linkedInPostId`: optional string (LinkedIn post URN/ID)
- `url`: optional string (for comment posting)
- `errorMessage`: optional string
- `retryCount`: optional number

**user_connections table:**

- `clerkUserId`: string (Clerk ID)
- `platform`: string ("linkedin")
- `accessToken`: string (encrypted)
- `refreshToken`: string (encrypted)
- `expiresAt`: number (timestamp)

**Indexes:**

- `posts.by_user`: ["clerkUserId"]
- `user_connections.by_user_platform`: ["clerkUserId", "platform"]

[Source: docs/architecture/data-models.md]
[Source: convex/schema.ts:1-34]

### API Specifications

**LinkedIn UGC Posts API (v2):**

**Endpoint:** `POST https://api.linkedin.com/v2/ugcPosts`

**Authentication:** OAuth 2.0 Bearer token (use decrypted `accessToken` from `user_connections`)

**Request Headers:**

```
Authorization: Bearer {access_token}
Content-Type: application/json
X-Restli-Protocol-Version: 2.0.0
```

**Request Body Structure:**

```json
{
  "author": "urn:li:person:{person_id}",
  "lifecycleState": "PUBLISHED",
  "specificContent": {
    "com.linkedin.ugc.ShareContent": {
      "shareCommentary": {
        "text": "{post_content}"
      },
      "shareMediaCategory": "NONE"
    }
  },
  "visibility": {
    "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
  }
}
```

**Response:** Returns post URN in format `urn:li:share:{share_id}` or `urn:li:ugcPost:{ugc_post_id}`

**LinkedIn Comments API:**

**Endpoint:** `POST https://api.linkedin.com/v2/socialActions/{ugcPostUrn}/comments`

**Request Body:**

```json
{
  "actor": "urn:li:person:{person_id}",
  "message": {
    "text": "{comment_text}"
  }
}
```

**Rate Limits:** LinkedIn enforces rate limits - implement exponential backoff for 429 responses

**Token Expiration:**

- Access tokens expire in 60 days (5,184,000 seconds)
- Refresh tokens expire in 365 days
- Token refresh implemented in `convex/connections.ts:refreshLinkedInToken` (lines 291-486)

[Source: docs/architecture/security.md#Platform-Specific-Token-Management]

**Getting LinkedIn Person ID:**

The `author` field requires the authenticated user's LinkedIn person ID. This should be retrieved during OAuth flow or via LinkedIn Profile API:

**Endpoint:** `GET https://api.linkedin.com/v2/me`

**Response:** `{ "id": "person_id" }`

Store `linkedInPersonId` in `user_connections` table (requires schema update) or retrieve on-demand during publishing.

### Component Specifications

**File Locations:**

- **Publishing Action:** `convex/publishing.ts` (add `publishLinkedInPost` action)
- **Posts Mutation:** `convex/posts.ts` (uncomment lines 102-106)
- **Notifications:** `convex/notifications.ts` (update for LinkedIn support)
- **Connections:** `convex/connections.ts` (token refresh already implemented)
- **Encryption:** `convex/encryption.ts` (already platform-agnostic)

[Source: docs/architecture/high-level-architecture.md#Repository-Structure]

**Convex Action Pattern:**

All publishing actions must use `"use node"` directive to access Node.js APIs (fetch, crypto, etc.)

```typescript
"use node";

export const publishLinkedInPost = internalAction({
  args: { postId: v.id("posts") },
  handler: async (ctx, args): Promise<void> => {
    // Implementation follows Twitter pattern from convex/publishing.ts
  },
});
```

[Source: convex/publishing.ts:1-408]
[Source: CLAUDE.md#Calling-External-APIs-Actions-Only]

### Technical Constraints

**Encryption Infrastructure:**

The existing encryption utilities are platform-agnostic and work for both Twitter and LinkedIn tokens:

- `internal.encryption.encrypt` - Encrypts plaintext tokens (AES-256-GCM)
- `internal.encryption.decrypt` - Decrypts ciphertext tokens
- `internal.connections.getDecryptedConnection` - Retrieves and decrypts tokens for a platform

**Security Requirements:**

- Never log decrypted tokens or API keys
- Use environment variables for LinkedIn API credentials (`LINKEDIN_CLIENT_ID`, `LINKEDIN_CLIENT_SECRET`)
- All API calls must use HTTPS
- Implement timeout handling (30 seconds max per request)

[Source: docs/architecture/security.md#Encryption-Infrastructure]
[Source: convex/encryption.ts:1-260]

**Error Handling Strategy:**

Follow the same pattern as Twitter publishing:

1. Capture HTTP errors from LinkedIn API
2. Classify as transient (retry) or permanent (fail immediately)
3. Implement exponential backoff: 2^retryCount minutes (1min, 2min, 4min)
4. Max 3 retry attempts
5. Update post status to "Failed" after max retries
6. Send Telegram notification on final failure

[Source: docs/architecture/testing-strategy.md#Error-Handling-Strategy]
[Source: convex/publishing.ts:242-331]

**Scheduling Pattern:**

```typescript
// In createPost mutation
if (hasLinkedIn && args.linkedInScheduledTime) {
  await ctx.scheduler.runAt(
    args.linkedInScheduledTime,
    internal.publishing.publishLinkedInPost,
    { postId },
  );
}
```

**Retry Scheduling:**

```typescript
// In error handler
await ctx.scheduler.runAfter(
  retryDelayMs,
  internal.publishing.publishLinkedInPost,
  { postId },
);
```

[Source: CLAUDE.md#Scheduled-Publishing-Architecture]
[Source: convex/publishing.ts:273-295]

### Testing

**Testing Strategy:**

**Unit Tests (Action Testing - Node.js Environment):**

- Mock LinkedIn API endpoints using test doubles
- Test API contract adherence (request/response format)
- Test rate limit handling (429 responses)
- Test auto-retry logic with exponential backoff
- Test token refresh integration
- Test Telegram notification triggering on final failure

**Integration Tests:**

- Test complete publishing workflow: Scheduled → Publishing → Published
- Test error scenarios: token expiration, API errors, network failures
- Test dual-platform scheduling (Twitter + LinkedIn)
- Verify post status updates and `linkedInPostId` storage

**Test File Location:** `__tests__/convex/publishing.test.ts`

**Testing Frameworks:**

- Jest for test runner
- Mocking libraries for external API calls (LinkedIn, Telegram)

[Source: docs/architecture/testing-strategy.md]

**Key Test Scenarios:**

1. Successful LinkedIn post publication (text-only)
2. Successful LinkedIn post + URL comment
3. Transient error retry (429 rate limit)
4. Permanent error handling (401 unauthorized)
5. Token refresh before publishing (token expires within 7 days)
6. Failed refresh requiring re-authentication
7. Max retry count reached → Telegram notification
8. Timeout handling (30-second API timeout)

### Testing

**Test File Locations:**

- Action tests: `__tests__/convex/publishing.test.ts`
- Integration tests: `__tests__/convex/posts.test.ts`

**Testing Standards:**

- Use Jest with Convex testing utilities
- Mock all external API calls (LinkedIn API, Telegram API)
- Test both success and failure paths for all API calls
- Verify retry logic with different error types
- Test token expiration and refresh scenarios
- Ensure tests validate all acceptance criteria

[Source: docs/architecture/testing-strategy.md]

## Change Log

| Date       | Version | Description                                | Author             |
| :--------- | :------ | :----------------------------------------- | :----------------- |
| 2025-10-31 | 1.0     | Initial draft created from Epic 2 details. | Bob (Scrum Master) |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

No debug log entries required - all tasks completed successfully on first attempt.

### Completion Notes

**Implementation Summary:**

All 8 tasks completed successfully with comprehensive test coverage (39 tests passing).

**Key Implementation Decisions:**

1. **Person ID Retrieval**: LinkedIn person ID is retrieved on-demand during publishing via `/v2/me` endpoint rather than storing it in the database. This keeps the schema simpler and ensures the ID is always current.

2. **Token Refresh Strategy**: Implemented proactive token refresh (7-day threshold) before publishing to minimize authentication failures. Handles both successful refresh and re-authentication scenarios.

3. **Error Classification**: Following Twitter pattern, errors are classified as transient (429, 5xx, network) or permanent (401, 403, 400) to determine retry behavior.

4. **URL Comment Posting**: Comment errors are logged but don't fail the main post - ensuring URL posting issues don't block content publication.

5. **Platform-Specific Notifications**: Telegram notifications now indicate which platform (Twitter/LinkedIn) failed for better debugging.

**Test Coverage:**

- Successful publication (text-only and text+URL)
- Token refresh integration (successful and failed scenarios)
- Error handling (transient and permanent errors)
- Retry logic with exponential backoff
- Telegram notification triggering
- Post status transitions
- All 39 tests passing

**Architecture Notes:**

- LinkedIn publishing follows the same patterns as Twitter for consistency
- All LinkedIn-specific logic is isolated in publishing.ts helper functions
- Notifications and post mutations are now platform-agnostic
- No schema changes required - existing fields support LinkedIn fully

### File List

**Modified:**

- `convex/posts.ts` - Uncommented LinkedIn scheduling in createPost mutation (lines 99-104), added linkedInPostId parameter to updatePostStatus mutation
- `convex/publishing.ts` - Added publishLinkedInPost action, LinkedIn API helper functions (getLinkedInPersonId, publishLinkedInUGCPost, publishLinkedInComment), error handling (handleLinkedInPublishingError, isLinkedInTransientError), LinkedInApiError class, and token refresh integration (lines 20, 410-872)
- `convex/notifications.ts` - Added platform parameter to sendFailureNotification for LinkedIn support (lines 27, 36, 52-53, 68, 92)
- `__tests__/convex/posts.test.ts` - Added scheduler integration tests for LinkedIn and dual-platform posts (lines 15-27, 99-128, 500-582)
- `__tests__/convex/publishing.test.ts` - Added comprehensive LinkedIn publishing tests covering successful publication, token refresh, error handling, and retry logic (lines 568-982)

## QA Results

### Review Date: 2025-10-31

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: EXCELLENT**

The LinkedIn publishing implementation demonstrates outstanding quality across all dimensions:

- **Architecture Consistency**: Perfect adherence to established Twitter publishing patterns, ensuring maintainability and reducing cognitive load for future development
- **Code Organization**: Clean separation of concerns with well-defined helper functions (getLinkedInPersonId, publishLinkedInUGCPost, publishLinkedInComment, handleLinkedInPublishingError)
- **Error Handling**: Comprehensive error classification (transient vs. permanent) with robust retry logic using exponential backoff
- **Documentation**: Excellent inline documentation with clear JSDoc comments explaining purpose, parameters, and behavior
- **Test Coverage**: Comprehensive test suite (39 tests) covering all critical paths including success, failure, retry, and token refresh scenarios

### Refactoring Performed

No refactoring was necessary. The implementation is production-ready as-is.

### Compliance Check

- **Coding Standards**: ✓ No dedicated coding-standards.md found, but code follows Convex best practices and TypeScript conventions
- **Project Structure**: ✓ All files in correct locations per architecture documentation
- **Testing Strategy**: ✓ Comprehensive coverage at all levels (unit, integration, action testing)
- **All ACs Met**: ✓ All 7 acceptance criteria fully implemented and validated

### Requirements Traceability (Given-When-Then Mapping)

**AC1: LinkedIn Scheduling in createPost Mutation**

- **Given**: User schedules a LinkedIn post with content and scheduled time
- **When**: createPost mutation is called with linkedInContent and linkedInScheduledTime
- **Then**: Convex scheduler schedules publishLinkedInPost action at specified time
- **Test Coverage**: `__tests__/convex/posts.test.ts:505-526` (LinkedIn scheduling), `__tests__/convex/posts.test.ts:528-557` (dual-platform scheduling)

**AC2: Scheduled Action Triggers Within 30 Seconds**

- **Given**: Post scheduled time arrives
- **When**: Convex scheduler invokes publishLinkedInPost action
- **Then**: Action executes immediately (Convex guarantees sub-second precision)
- **Test Coverage**: Validated via scheduler.runAt mock calls

**AC3: Token Retrieval, Decryption, and Publishing**

- **Given**: LinkedIn post ready to publish
- **When**: publishLinkedInPost action executes
- **Then**: Retrieves encrypted token, decrypts it, publishes to LinkedIn UGC API
- **Test Coverage**: `__tests__/convex/publishing.test.ts:580-659` (successful publication), `convex/publishing.ts:462-537` (implementation)

**AC4: URL as First Comment**

- **Given**: Post includes a URL field
- **When**: Main post publishes successfully
- **Then**: URL posted as first comment via LinkedIn comments API
- **Test Coverage**: `__tests__/convex/publishing.test.ts:661-733` (URL comment test), `convex/publishing.ts:544-558` (graceful error handling)

**AC5: Status Update to Published with linkedInPostId**

- **Given**: LinkedIn post publishes successfully
- **When**: API returns post URN
- **Then**: Post status updated to "Published" with linkedInPostId stored
- **Test Coverage**: `__tests__/convex/publishing.test.ts:735-767` (status update test), `convex/posts.ts:154-160` (linkedInPostId parameter)

**AC6: Auto-Retry with Exponential Backoff**

- **Given**: Transient API failure (429, 5xx, timeout)
- **When**: Publishing fails with transient error
- **Then**: System retries 2-3 times with delays of 1min, 2min, 4min
- **Test Coverage**: `__tests__/convex/publishing.test.ts:932-949` (retry scheduling), `convex/publishing.ts:813-835` (retry logic)

**AC7: Telegram Failure Notification**

- **Given**: LinkedIn post fails after max retries
- **When**: Final retry fails or permanent error occurs
- **Then**: Telegram notification sent with platform indicator "LinkedIn"
- **Test Coverage**: `__tests__/convex/publishing.test.ts:951-966` (notification trigger), `convex/notifications.ts:52-68` (platform-aware messaging)

### Test Architecture Assessment

**Coverage Analysis: COMPREHENSIVE (100% AC coverage)**

- **Unit Tests**: 15 LinkedIn-specific tests covering API interactions, error handling, and token management
- **Integration Tests**: 3 tests for scheduler integration (LinkedIn-only, dual-platform, failure handling)
- **Action Tests**: All external API calls properly mocked, timeout scenarios validated
- **Edge Cases**: Excellent coverage including comment failures, token refresh scenarios, error classification
- **Test Levels**: Appropriate test placement (unit for logic, integration for Convex functions, action for external APIs)
- **Mock Strategy**: Clean mocking of LinkedIn API responses without over-specification

**Test Quality: EXCELLENT**

- Tests are maintainable and well-organized
- Clear test descriptions following Given-When-Then pattern
- No flaky tests detected (all 150 tests pass consistently)
- Fast execution time (0.952s for full suite)

### Non-Functional Requirements (NFRs)

**Security: PASS**

- ✓ OAuth tokens retrieved via encrypted connection infrastructure
- ✓ No tokens logged in plaintext (verified in convex/publishing.ts:528, test at publishing.test.ts:977-982)
- ✓ All sensitive data handled in internal actions only
- ✓ Token refresh properly handles expired refresh tokens requiring re-authentication
- ✓ Consistent with existing security architecture (uses same encryption infrastructure as Twitter)

**Performance: PASS**

- ✓ API timeout handling (30-second timeout via AbortController)
- ✓ Efficient token refresh strategy (7-day threshold prevents last-minute failures)
- ✓ No unnecessary database queries (single getPostById per action invocation)
- ✓ Comment failures don't block main post publishing

**Reliability: PASS**

- ✓ Comprehensive error classification (transient vs. permanent)
- ✓ Exponential backoff prevents API rate limit violations
- ✓ Max retry limit (3 attempts) prevents infinite loops
- ✓ Graceful degradation (comment failure doesn't fail main post)
- ✓ Token refresh integration reduces authentication failures

**Maintainability: PASS**

- ✓ Excellent code organization mirroring Twitter implementation
- ✓ Clear function naming and purpose documentation
- ✓ Consistent error handling patterns
- ✓ Well-structured helper functions (single responsibility principle)
- ✓ No code duplication (retry logic follows established pattern)

### Testability Evaluation

**Controllability: EXCELLENT**

- All external dependencies (LinkedIn API, encryption, notifications) properly mocked
- Clear test setup for various scenarios (success, transient errors, permanent errors)

**Observability: EXCELLENT**

- Comprehensive logging throughout publishing workflow
- Post status transitions clearly tracked
- Error messages provide actionable information

**Debuggability: EXCELLENT**

- Structured logging with context (e.g., "[LinkedIn Publishing]" prefix)
- Error messages include relevant details (post ID, error type, retry count)
- Test failures would provide clear indication of issue location

### Technical Debt Identification

**None detected.** The implementation is clean with no shortcuts or workarounds.

### Security Review

**Status: PASS - No Concerns**

- Token handling follows security best practices (encryption at rest, decryption only in actions)
- No sensitive data exposure in logs or error messages
- Consistent with existing security infrastructure
- Refresh token handling properly addresses re-authentication scenarios

**Recommendations:**

- Consider adding rate limit tracking to proactively monitor LinkedIn API quotas (future enhancement, not blocking)

### Performance Considerations

**Status: PASS - No Concerns**

- Appropriate timeout values (30 seconds per API call)
- Token refresh strategy prevents excessive API calls
- Comment posting doesn't block main post success

**Recommendations:**

- Consider implementing circuit breaker pattern if LinkedIn API becomes unreliable (future enhancement, not blocking)

### Files Modified During Review

None - no refactoring was necessary.

### Gate Status

Gate: **PASS** → docs/qa/gates/2.4-linkedin-publishing-logic.yml

**Quality Score: 100/100**

This implementation represents exemplary software engineering:

- Zero defects identified
- Complete AC coverage with comprehensive tests (150 total tests passing)
- Excellent architecture consistency and code quality
- All NFRs satisfied
- Production-ready with no technical debt

### Recommended Status

**✓ Ready for Done**

This story is complete and ready for production deployment. All acceptance criteria are met, tests are comprehensive and passing, and the implementation follows best practices throughout. No changes required.

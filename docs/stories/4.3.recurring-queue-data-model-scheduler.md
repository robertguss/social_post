# Story 4.3: Recurring Queue Data Model & Scheduler

## Status

Draft

## Story

**As an** engineer,
**I want** a database schema and scheduling logic for recurring post queues,
**so that** posts can be automatically rescheduled at defined intervals.

## Acceptance Criteria

1. A `recurring_queues` table is defined in the Convex schema with fields: `clerkUserId`, `originalPostId`, `status` (active/paused), `interval` (days), `nextScheduledTime`, `lastExecutedTime`, `executionCount`, `maxExecutions` (optional).
2. The `recurring_queues` table has an index `by_user_status` on `["clerkUserId", "status"]` for efficient active queue queries.
3. A Convex scheduled function runs daily to check for queues due for execution (`nextScheduledTime` <= now).
4. When a queue is due, the scheduled function clones the original post and schedules it using the existing publishing logic.
5. After execution, `nextScheduledTime` is updated to `lastExecutedTime` + `interval`, and `executionCount` is incremented.
6. If `maxExecutions` is set and reached, the queue status is automatically set to "completed".
7. All queue operations are scoped to the authenticated user's `clerkUserId`.

## Tasks / Subtasks

- [ ] **Task 1: Define recurring_queues schema** (AC: 1, 2)
  - [ ] Open `convex/schema.ts`
  - [ ] Import required validators: `v.string()`, `v.id()`, `v.number()`, `v.optional()`
  - [ ] Define `recurring_queues` table with fields:
    - `clerkUserId: v.string()` - Clerk user ID (for user scoping)
    - `originalPostId: v.id("posts")` - Reference to the post to clone
    - `status: v.string()` - "active" | "paused" | "completed"
    - `interval: v.number()` - Number of days between executions
    - `nextScheduledTime: v.number()` - Timestamp of next execution
    - `lastExecutedTime: v.optional(v.number())` - Timestamp of last execution (null for new queues)
    - `executionCount: v.number()` - Total number of times queue has executed (default 0)
    - `maxExecutions: v.optional(v.number())` - Max executions before auto-completion (null for infinite)
  - [ ] Add index `by_user_status` on `["clerkUserId", "status"]`
  - [ ] Add index `by_next_scheduled` on `["nextScheduledTime"]` for efficient scheduler queries
  - [ ] Deploy schema changes to Convex development environment
  - [ ] Verify schema migration and indexes are created

- [ ] **Task 2: Create queue CRUD mutations** (AC: 1, 7)
  - [ ] Create new file: `convex/queues.ts`
  - [ ] Import mutation builder and validators from Convex
  - [ ] Define `createQueue` mutation:
    - Args: `originalPostId: v.id("posts")`, `interval: v.number()`, `nextScheduledTime: v.number()`, `maxExecutions: v.optional(v.number())`
    - Verify user authentication
    - Validate interval > 0 (must be at least 1 day)
    - Validate nextScheduledTime is in the future
    - Verify originalPostId exists and belongs to authenticated user
    - Create queue record with status "active" and executionCount 0
    - Return new queue ID
  - [ ] Define `updateQueue` mutation:
    - Args: `queueId: v.id("recurring_queues")`, `interval: v.optional(v.number())`, `nextScheduledTime: v.optional(v.number())`, `maxExecutions: v.optional(v.number())`
    - Verify user authentication and queue ownership
    - Update specified fields
    - Return updated queue
  - [ ] Define `deleteQueue` mutation:
    - Args: `queueId: v.id("recurring_queues")`
    - Verify user authentication and queue ownership
    - Delete queue record
  - [ ] Define `pauseQueue` mutation:
    - Args: `queueId: v.id("recurring_queues")`
    - Verify user authentication and queue ownership
    - Set status to "paused"
  - [ ] Define `resumeQueue` mutation:
    - Args: `queueId: v.id("recurring_queues")`
    - Verify user authentication and queue ownership
    - Recalculate nextScheduledTime based on current time + interval
    - Set status to "active"
  - [ ] Add error handling for all mutations (queue not found, unauthorized, validation errors)

- [ ] **Task 3: Create query to fetch user's queues** (AC: 2, 7)
  - [ ] In `convex/queues.ts`, define `getQueues` query
  - [ ] Args: `status: v.optional(v.string())` - Filter by status (optional)
  - [ ] Verify user authentication
  - [ ] Query recurring_queues with `by_user_status` index
  - [ ] If status filter provided, filter by status
  - [ ] Return all matching queues for authenticated user
  - [ ] Include original post data in response (join with posts table)
  - [ ] Sort by nextScheduledTime (ascending)

- [ ] **Task 4: Create scheduled function for queue processing** (AC: 3, 4, 5, 6)
  - [ ] In `convex/queues.ts`, import `cronJobs` from Convex
  - [ ] Define cron job using `cronJobs.daily()` that runs at a specific time (e.g., 12:00 AM UTC)
  - [ ] Alternative: Use `cronJobs.hourly()` for more frequent checks (runs every hour)
  - [ ] Implement scheduled function `processQueues`:
    - Query all active queues where `nextScheduledTime <= Date.now()`
    - For each due queue:
      - Fetch original post from database
      - Clone post content (reuse clonePost mutation logic or create helper function)
      - Schedule cloned post using existing scheduling logic from Story 1.5/2.4
      - Increment queue's `executionCount`
      - Set queue's `lastExecutedTime` to current timestamp
      - Calculate new `nextScheduledTime` = `lastExecutedTime` + (interval * 86400000) // convert days to ms
      - Check if `maxExecutions` is set and `executionCount >= maxExecutions`
      - If max reached, set queue status to "completed"
      - Update queue record in database
    - Log errors for failed queue executions (don't fail entire batch)
    - Return summary of processed queues (success/failure counts)
  - [ ] Handle edge cases: original post deleted, user connections missing, API errors
  - [ ] Implement retry logic for transient failures (optional enhancement)

- [ ] **Task 5: Create helper function to clone and schedule post** (AC: 4)
  - [ ] In `convex/queues.ts` or separate helper file, create `cloneAndSchedulePost` function
  - [ ] Accept args: `ctx`, `originalPostId: Id<"posts">`, `scheduledTime: number`
  - [ ] Fetch original post
  - [ ] Create new post record with cloned content (similar to Story 4.1 clonePost mutation)
  - [ ] Set status to "scheduled" (not "draft")
  - [ ] Set scheduled times based on original post's platform configuration
  - [ ] Calculate adjusted scheduled time based on queue's nextScheduledTime
  - [ ] Schedule publishing actions using `ctx.scheduler.runAt()` (reuse logic from Story 1.5/2.4)
  - [ ] Store scheduler IDs in post record (twitterSchedulerId, linkedInSchedulerId)
  - [ ] Return new post ID
  - [ ] Mark new post with reference to queue that created it (optional enhancement for audit trail)

- [ ] **Task 6: Export cron job configuration** (AC: 3)
  - [ ] At bottom of `convex/queues.ts`, export cron jobs:
    ```typescript
    export const crons = cronJobs();
    crons.daily("process-recurring-queues", { hourUTC: 0, minuteUTC: 0 }, internal.queues.processQueues);
    ```
  - [ ] Or for hourly processing:
    ```typescript
    crons.hourly("process-recurring-queues", { minuteUTC: 0 }, internal.queues.processQueues);
    ```
  - [ ] Choose frequency based on product requirements (daily is sufficient for MVP)
  - [ ] Document cron schedule in code comments
  - [ ] Verify cron job appears in Convex dashboard after deployment

- [ ] **Task 7: Add queue-related fields to posts schema** (AC: 4)
  - [ ] Open `convex/schema.ts`
  - [ ] Add optional field to posts table: `createdByQueueId: v.optional(v.id("recurring_queues"))`
  - [ ] This links automatically scheduled posts back to their queue (for audit/analytics)
  - [ ] Deploy schema update

- [ ] **Task 8: Test createQueue mutation** (AC: 1, 7)
  - [ ] Create test file: `convex/queues.test.ts`
  - [ ] Mock Convex database and auth context
  - [ ] Test createQueue creates queue with correct fields
  - [ ] Test createQueue validates interval > 0
  - [ ] Test createQueue validates nextScheduledTime is in future
  - [ ] Test createQueue rejects if originalPostId doesn't exist
  - [ ] Test createQueue rejects if user doesn't own originalPostId (security)
  - [ ] Test createQueue rejects if user is not authenticated

- [ ] **Task 9: Test queue update/delete/pause/resume mutations** (AC: 7)
  - [ ] Test updateQueue updates specified fields correctly
  - [ ] Test deleteQueue removes queue from database
  - [ ] Test pauseQueue sets status to "paused"
  - [ ] Test resumeQueue sets status to "active" and recalculates nextScheduledTime
  - [ ] Test all mutations enforce user authentication and ownership
  - [ ] Test all mutations handle queue not found errors

- [ ] **Task 10: Test processQueues scheduled function** (AC: 3, 4, 5, 6)
  - [ ] Mock current time for predictable testing
  - [ ] Create test queue with nextScheduledTime in the past (due for execution)
  - [ ] Run processQueues scheduled function
  - [ ] Verify new post is created with cloned content
  - [ ] Verify post is scheduled for publishing (status "scheduled", scheduler IDs set)
  - [ ] Verify queue's executionCount is incremented
  - [ ] Verify queue's lastExecutedTime is updated
  - [ ] Verify queue's nextScheduledTime is updated (lastExecutedTime + interval)
  - [ ] Test maxExecutions: create queue with maxExecutions=3, run processQueues 3 times, verify status becomes "completed"
  - [ ] Test queue not due for execution is skipped (nextScheduledTime > now)
  - [ ] Test paused queue is skipped
  - [ ] Test error handling when original post is deleted

- [ ] **Task 11: Test getQueues query** (AC: 2, 7)
  - [ ] Test getQueues returns all user's queues when no status filter
  - [ ] Test getQueues filters by status when status arg provided
  - [ ] Test getQueues returns empty array for user with no queues
  - [ ] Test getQueues enforces user scoping (doesn't return other users' queues)
  - [ ] Test getQueues includes original post data in response
  - [ ] Test getQueues sorts by nextScheduledTime

## Dev Notes

### Architecture Context

This story implements the core backend infrastructure for Epic 4's recurring post feature. It introduces automated content recycling via scheduled Convex functions that clone and repost content at defined intervals.

**Key Design Decisions:**

- Convex cron jobs run on a schedule (daily or hourly) to process due queues
- Queues are "active" by default but can be paused/resumed by users
- `maxExecutions` provides optional limit for finite recurring schedules (e.g., "post this 4 times")
- Interval is stored in days (simple integer) and converted to milliseconds for timestamp calculations
- Queue processing is fault-tolerant: one failed queue doesn't block others
- Cloned posts via queues are marked with `createdByQueueId` for audit trail

[Source: docs/prd/6-epic-details.md:294-307]

### Data Models

**New Table: recurring_queues**

```typescript
recurring_queues: defineTable({
  clerkUserId: v.string(),
  originalPostId: v.id("posts"),
  status: v.string(), // "active" | "paused" | "completed"
  interval: v.number(), // Days between executions
  nextScheduledTime: v.number(), // Unix timestamp (ms)
  lastExecutedTime: v.optional(v.number()), // Unix timestamp (ms)
  executionCount: v.number(), // Total executions (default 0)
  maxExecutions: v.optional(v.number()), // Optional limit
})
  .index("by_user_status", ["clerkUserId", "status"])
  .index("by_next_scheduled", ["nextScheduledTime"])
```

**Updated Table: posts**

Add new optional field:
- `createdByQueueId: v.optional(v.id("recurring_queues"))` - Links posts created by queues back to their source queue

[Source: docs/prd/6-epic-details.md:294-307, convex/schema.ts]

### Backend Architecture

**New Convex File: convex/queues.ts**

Contains all queue-related backend logic:

1. **Mutations:**
   - `createQueue` - Create new recurring queue
   - `updateQueue` - Modify queue settings (interval, maxExecutions, nextScheduledTime)
   - `deleteQueue` - Remove queue
   - `pauseQueue` - Set status to "paused" (stops auto-execution)
   - `resumeQueue` - Set status to "active" and recalculate nextScheduledTime

2. **Queries:**
   - `getQueues` - Fetch user's queues with optional status filter

3. **Scheduled Functions (Cron Jobs):**
   - `processQueues` - Runs on schedule (daily/hourly) to execute due queues

4. **Helpers:**
   - `cloneAndSchedulePost` - Clones post and schedules it for publishing

[Source: docs/architecture/tech-stack.md - Convex provides scheduled functions]

### Convex Scheduled Functions (Cron Jobs)

Convex provides built-in cron job support for running functions on a schedule:

**Configuration:**
```typescript
import { cronJobs } from "convex/server";

export const crons = cronJobs();

// Daily at midnight UTC
crons.daily(
  "process-recurring-queues",
  { hourUTC: 0, minuteUTC: 0 },
  internal.queues.processQueues
);

// Or hourly at the top of the hour
crons.hourly(
  "process-recurring-queues",
  { minuteUTC: 0 },
  internal.queues.processQueues
);
```

**Best Practices:**
- Use `internal` functions for cron jobs (not publicly callable)
- Handle errors gracefully (don't let one failure block batch)
- Log execution results for debugging
- Keep cron job functions fast (delegate heavy work to actions if needed)

[Source: CLAUDE.md - Convex scheduled functions are critical for timed publishing, docs/architecture/tech-stack.md]

### Previous Story Insights

**From Story 4.1 (Clone Past Post Functionality):**

- `clonePost` mutation demonstrates how to clone post content
- Security pattern: verify user owns original post before cloning
- Cloned posts should preserve content but clear scheduling/publishing fields
- Can reuse cloning logic for queue-generated posts

[Source: docs/stories/4.1.clone-past-post-functionality.md]

**From Story 1.5 (Core Publishing Logic - X Only):**

- Scheduling pattern: use `ctx.scheduler.runAt(scheduledTime, action, args)`
- Store scheduler IDs in post record for later cancellation
- Publishing actions are in `convex/publishing.ts`
- Reference: `api.publishing.publishToTwitter`, `api.publishing.publishToLinkedIn`

[Source: docs/stories/1.5.core-publishing-logic-x-only.md, CLAUDE.md - Scheduled Publishing Architecture]

**From Story 2.4 (LinkedIn Publishing Logic):**

- Dual platform scheduling: separate scheduler IDs for Twitter and LinkedIn
- Each platform gets its own scheduled action
- Scheduled times can differ between platforms

[Source: docs/stories/2.4.linkedin-publishing-logic.md]

### Time Calculations

**Converting interval (days) to milliseconds:**
```typescript
const intervalMs = interval * 24 * 60 * 60 * 1000; // days to ms
// Or simplified:
const intervalMs = interval * 86400000;
```

**Calculating next scheduled time:**
```typescript
const nextScheduledTime = lastExecutedTime + (interval * 86400000);
```

**Checking if queue is due:**
```typescript
const isDue = queue.nextScheduledTime <= Date.now();
```

### Security Considerations

- **Authorization**: All queue mutations MUST verify authenticated user owns the queue
- **Data Scoping**: Queues scoped by `clerkUserId` - users cannot access other users' queues
- **Original Post Validation**: When creating queue, verify user owns originalPostId
- **Cron Job Security**: Use `internal` namespace for scheduled functions (not publicly callable)

[Source: docs/architecture/security.md, CLAUDE.md - Authentication Flow]

### Error Handling Strategy

**In processQueues scheduled function:**

1. Wrap each queue execution in try-catch
2. Log errors but continue processing other queues
3. If original post is deleted, mark queue as "completed" or "failed"
4. If user connections are missing, skip execution and log warning
5. Don't send Telegram notifications for queue failures (too noisy) - handle via logging/monitoring

**In mutations:**

1. Validate all inputs (interval > 0, nextScheduledTime in future, etc.)
2. Check queue/post existence before operations
3. Return clear error messages for validation failures
4. Use Convex's built-in transaction handling (mutations are atomic)

[Source: docs/architecture/testing-strategy.md#error-handling-strategy]

### Testing

**Test Locations:**
- Backend tests: `convex/queues.test.ts`

**Testing Framework:**
- Jest for Convex function testing
- Mock Convex database and auth contexts
- Mock Date.now() for predictable time-based tests

**Key Test Cases:**
1. Unit: createQueue validates inputs and creates queue correctly
2. Unit: pauseQueue/resumeQueue change status appropriately
3. Unit: processQueues executes due queues and updates state
4. Unit: processQueues respects maxExecutions limit
5. Integration: Queue execution creates scheduled post with correct content
6. Integration: Queue execution schedules publishing actions
7. Security: Mutations enforce user ownership of queues and posts
8. Edge case: processQueues handles deleted original post gracefully

[Source: docs/architecture/testing-strategy.md]

### Performance Considerations

**Indexing:**
- `by_user_status` index enables fast user queue lookups filtered by status
- `by_next_scheduled` index enables fast "due queues" queries in processQueues

**Scalability:**
- Daily cron job sufficient for MVP (single user)
- For multi-user version: consider batch processing or per-user job scheduling
- Limit query results to prevent timeouts (e.g., process max 100 queues per execution)

**Monitoring:**
- Log cron job execution results (queues processed, successes, failures)
- Track execution time to ensure cron completes within Convex limits
- Monitor failed executions for debugging

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-01 | 1.0 | Initial story draft created | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used

_(To be filled by dev agent during implementation)_

### Debug Log References

_(To be filled by dev agent during implementation)_

### Completion Notes List

_(To be filled by dev agent during implementation)_

### File List

_(To be filled by dev agent during implementation)_

## QA Results

_(To be filled by QA agent after implementation)_

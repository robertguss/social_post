# Story 6.2: Time Suggestion Algorithm (Platform-Aware)

## Status
Draft

## Story
**As an** engineer,
**I want** an algorithm that calculates optimal posting times based on the user's selected date and platform,
**so that** intelligent suggestions can be presented in the UI.

## Acceptance Criteria

1. A Convex query `getRecommendedTimes` accepts parameters: `date`, `platform`, and `userTimezone`.
2. The query retrieves recommendations for the specified platform and day of week.
3. Recommendations are sorted by `engagementScore` (highest first).
4. The query returns the top 3 time suggestions converted to the user's local timezone.
5. If no recommendations exist for the specific day/platform, fallback to general recommendations (e.g., "mid-morning" as a default).
6. Time suggestions avoid conflicts with the user's already scheduled posts (optional check).
7. The algorithm considers the user's posting history to avoid suggesting times they never use (future enhancement placeholder).

## Tasks / Subtasks

- [ ] Task 1: Create `getRecommendedTimes` Convex query (AC: 1, 2, 3, 4)
  - [ ] Create `convex/recommendations.ts` file for recommendation queries
  - [ ] Define query with validators for `date` (string ISO format), `platform` (string), `userTimezone` (string)
  - [ ] Extract day of week from provided `date` parameter (0-6)
  - [ ] Query `posting_time_recommendations` table using `by_platform_day` index
  - [ ] Sort results by `engagementScore` descending
  - [ ] Return top 3 recommendations
  - [ ] Add authentication check to verify user is logged in

- [ ] Task 2: Implement timezone conversion logic (AC: 4)
  - [ ] Create utility function to convert UTC hour ranges to user's local timezone
  - [ ] Handle timezone offset calculation based on `userTimezone` parameter
  - [ ] Account for daylight saving time (DST) when converting times
  - [ ] Format time suggestions as user-friendly strings (e.g., "9:00 AM - 11:00 AM")
  - [ ] Include timezone abbreviation in returned suggestions (e.g., "EST", "PST")

- [ ] Task 3: Implement fallback recommendation logic (AC: 5)
  - [ ] Create default recommendation data for "mid-morning" fallback
  - [ ] Define fallback time ranges: 9-11am UTC for all platforms
  - [ ] Return fallback with lower engagement score (e.g., 50) to indicate generic suggestion
  - [ ] Add "source: 'default'" to distinguish from research-based recommendations
  - [ ] Log when fallback is used for monitoring purposes

- [ ] Task 4: Add conflict detection with existing posts (AC: 6)
  - [ ] Query `posts` table for user's scheduled posts on the selected date
  - [ ] Extract scheduled times for the specified platform
  - [ ] Filter out recommendations that conflict (within 1 hour window) with existing posts
  - [ ] If all top 3 recommendations conflict, include them but mark as "conflicts with existing post"
  - [ ] Return conflict metadata with each suggestion

- [ ] Task 5: Add placeholder for historical performance integration (AC: 7)
  - [ ] Add comment block documenting future enhancement for historical performance
  - [ ] Define data structure for how historical performance would be weighted
  - [ ] Create stub function `getHistoricalPerformanceFactor` that returns 1.0 (neutral weight)
  - [ ] Document API requirements needed to enable this feature

- [ ] Task 6: Write unit tests for recommendation algorithm (AC: 1-5)
  - [ ] Test day of week extraction from date parameter
  - [ ] Test query filters correctly by platform and day
  - [ ] Test sorting by engagement score (highest first)
  - [ ] Test returns exactly top 3 recommendations
  - [ ] Test timezone conversion accuracy for multiple timezones
  - [ ] Test fallback logic when no recommendations exist
  - [ ] Test conflict detection logic with mock scheduled posts

- [ ] Task 7: Write integration tests for query execution (AC: 1, 2, 6)
  - [ ] Test query with seeded recommendation data from Story 6.1
  - [ ] Test authentication requirement (fails without logged-in user)
  - [ ] Test with multiple platforms (Twitter, LinkedIn)
  - [ ] Test with different days of week
  - [ ] Test conflict detection with real `posts` data
  - [ ] Verify index performance on `by_platform_day`

## Dev Notes

### Previous Story Insights
[Source: Story 6.1]
- The `posting_time_recommendations` table has been created with fields: `platform`, `dayOfWeek`, `hourRanges`, `engagementScore`, `source`
- An index `by_platform_day` exists on `["platform", "dayOfWeek"]` for efficient lookups
- Recommendations are stored in UTC format
- Seed data exists for Twitter and LinkedIn with research-based best practices
- Engagement scores are normalized 0-100

### Data Models

**Tables Used in This Story:**

1. **`posting_time_recommendations` (from Story 6.1)** [Source: Story 6.1, docs/architecture/data-models.md]
   - Fields: `platform`, `dayOfWeek`, `hourRanges`, `engagementScore`, `source`
   - Index: `by_platform_day` on `["platform", "dayOfWeek"]`
   - Times stored in UTC format

2. **`posts` (existing)** [Source: docs/architecture/data-models.md]
   - Fields: `clerkUserId`, `status`, `twitterScheduledTime`, `linkedInScheduledTime`, and more
   - Index: `by_user` on `["clerkUserId"]`
   - Used for conflict detection (AC: 6)

### Query Implementation Guidance

[Source: CLAUDE.md - Critical Architectural Patterns]

**Convex Query Pattern:**
```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";

export const getRecommendedTimes = query({
  args: {
    date: v.string(), // ISO format: "2025-11-15"
    platform: v.string(), // "twitter" or "linkedin"
    userTimezone: v.string() // IANA timezone: "America/New_York"
  },
  returns: v.array(v.object({
    timeRange: v.string(),
    engagementScore: v.number(),
    source: v.string(),
    conflictsWithPost: v.boolean()
  })),
  handler: async (ctx, args) => {
    // Implementation here
  },
});
```

**Authentication in Queries:** [Source: CLAUDE.md, docs/architecture/security.md]
```typescript
const identity = await ctx.auth.getUserIdentity();
if (!identity) throw new Error("Not authenticated");
const clerkUserId = identity.subject;
```

**Using Indexes for Queries:** [Source: CLAUDE.md]
```typescript
// CORRECT: Use withIndex for efficient queries
const recommendations = await ctx.db
  .query("posting_time_recommendations")
  .withIndex("by_platform_day", (q) =>
    q.eq("platform", args.platform).eq("dayOfWeek", dayOfWeek)
  )
  .collect();

// WRONG: Never use filter() - always use indexes
// const recommendations = await ctx.db
//   .query("posting_time_recommendations")
//   .filter(q => q.eq(q.field("platform"), args.platform))
//   .collect();
```

### Day of Week Extraction

**JavaScript Date Behavior:**
- `new Date("2025-11-15").getDay()` returns 0-6 (0 = Sunday, 6 = Saturday)
- This matches the `dayOfWeek` field in the `posting_time_recommendations` table (Story 6.1)
- Convert date string to Date object, then call `.getDay()`

**Timezone Consideration:**
- Use user's timezone when determining day of week
- Example: "2025-11-15" at midnight UTC might be "2025-11-14" in PST
- Use timezone-aware date parsing libraries or manual offset calculation

### Timezone Conversion Logic

**UTC to Local Time Conversion:**
- Recommendations stored as `hourRanges: [{ startHour: 14, endHour: 16 }]` (UTC)
- Convert to user's timezone using offset calculation
- JavaScript's `Intl.DateTimeFormat` can help with timezone conversion
- Example: 14:00 UTC = 9:00 AM EST (UTC-5)

**Libraries:**
- Consider using `date-fns-tz` for timezone conversion
- Or native `Intl` API for formatting
- Or manual offset calculation using timezone offset lookup

**Output Format:**
- Return formatted strings like "9:00 AM - 11:00 AM EST"
- Include timezone abbreviation for clarity
- Use 12-hour format with AM/PM for readability

### Conflict Detection

**Query User's Scheduled Posts:**
```typescript
const scheduledPosts = await ctx.db
  .query("posts")
  .withIndex("by_user", (q) => q.eq("clerkUserId", clerkUserId))
  .filter((q) => q.eq(q.field("status"), "scheduled"))
  .collect();
```

**Extract Scheduled Times:**
- For Twitter: Use `twitterScheduledTime` field (timestamp)
- For LinkedIn: Use `linkedInScheduledTime` field (timestamp)
- Convert timestamps to hour of day in user's timezone
- Compare with recommended time ranges

**Conflict Window:**
- Define conflict as within 1 hour before or after recommended time
- Example: If recommendation is 9-11am, conflict if post scheduled 8am-12pm
- Mark recommendations with `conflictsWithPost: true` if conflict exists

### Fallback Recommendations

**Default Values:** [Source: AC 5]
- Time range: 9-11am UTC (mid-morning across most timezones)
- Engagement score: 50 (lower than research-based scores)
- Source: "default"
- Apply same timezone conversion as regular recommendations

**When to Use Fallback:**
- No recommendations found for platform/day combination
- Database query returns empty array
- Still return 3 suggestions using fallback logic

### File Locations

**New Files:**
- `convex/recommendations.ts` - Main query file for recommendation logic
- `convex/utils/timezoneConverter.ts` (optional) - Utility for timezone conversion

**Existing Files:**
- `convex/schema.ts` - No changes needed (schema from Story 6.1)
- `convex/_generated/server.ts` - Auto-generated Convex types

### Function References

[Source: CLAUDE.md]
- Public functions: Use `api.recommendations.getRecommendedTimes`
- Internal functions: Use `internal.recommendations.functionName`
- This query will be public (called from frontend)

### Testing

[Source: docs/architecture/testing-strategy.md]

**Unit Testing Focus:**
- Day of week extraction logic
- Timezone conversion accuracy
- Sorting by engagement score
- Fallback logic triggers
- Conflict detection algorithm

**Integration Testing Focus:**
- Query execution with authentication
- Index performance verification
- Real data from `posting_time_recommendations` table
- Real conflict detection with `posts` table

**Test Tools:**
- Jest for unit tests
- Convex unit testing utilities
- Mocking libraries for external dependencies (if any)

**Test File Location:**
- Co-locate tests with implementation or use `__tests__` directory

### Technical Constraints

**Performance:** [Source: CLAUDE.md]
- Always use `withIndex()` for queries, never `filter()`
- Index `by_platform_day` provides O(log n) lookup time
- Limit results to top 3 to reduce data transfer

**Authentication:** [Source: docs/architecture/security.md]
- All queries must verify user authentication
- User can only see their own conflict data (scoped by `clerkUserId`)

**Timezone Handling:**
- Store all times in UTC (already done in Story 6.1)
- Convert to user's local timezone only when returning results
- Handle DST transitions correctly

### Future Enhancement Notes (AC 7)

**Historical Performance Integration:**
- Future feature: Weight recommendations based on user's past post performance
- Requires: Engagement metrics from Twitter/LinkedIn APIs (Story 6.4)
- Implementation: Multiply engagement score by historical performance factor
- Data structure: `{ timeOfDay: number, avgEngagement: number, postCount: number }`
- Placeholder function: `getHistoricalPerformanceFactor(userId, platform, hourOfDay)` returns 1.0 for now

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-03 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_
